<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../../style.css">
        <link rel="stylesheet" type="text/css" href="../../paren-soup-light.css">
    </head>
    <body>
        <span id="app"><div data-reactroot="" data-reactid="1" data-react-checksum="-386310647"><div style="left:0;" class="vars" data-reactid="2"><!-- react-empty: 3 --><div class="var-info" data-reactid="4"><div data-reactid="5"><h2 data-reactid="6">(parse-example args)</h2></div><div class="section" data-reactid="7"><h2 data-reactid="8">Source</h2><div class="paren-soup" data-reactid="9"><div class="content" data-reactid="10"><span class='collection list'><span class='delimiter'>(</span><span class='symbol'>defn</span> <span class='symbol'>parse-example</span> <span class='collection vector'><span class='delimiter'>[</span><span class='symbol'>args</span><span class='delimiter'>]</span></span>
  <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>let</span> <span class='collection vector'><span class='delimiter'>[</span><span class='collection map'><span class='delimiter'>{</span><span class='keyword'>:keys</span> <span class='collection vector'><span class='delimiter'>[</span><span class='symbol'>meta</span> <span class='symbol'>body</span><span class='delimiter'>]</span></span><span class='delimiter'>}</span></span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>s/conform</span> <span class='keyword'>::args</span> <span class='symbol'>args</span><span class='delimiter'>)</span></span>
        <span class='symbol'>_</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>when</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>=</span> <span class='symbol'>meta</span> <span class='keyword'>:clojure.spec/invalid</span><span class='delimiter'>)</span></span>
            <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>throw</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>Exception.</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>str</span> <span class='string'>&quot;Invalid args: &quot;</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>pr-str</span> <span class='symbol'>args</span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span>
        <span class='collection vector'><span class='delimiter'>[</span><span class='symbol'>meta-type</span> <span class='symbol'>meta-val</span><span class='delimiter'>]</span></span> <span class='symbol'>meta</span>
        <span class='symbol'>opts</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>case</span> <span class='symbol'>meta-type</span>
               <span class='keyword'>:doc</span> <span class='collection map'><span class='delimiter'>{</span><span class='keyword'>:doc</span> <span class='symbol'>meta-val</span><span class='delimiter'>}</span></span>
               <span class='keyword'>:opts</span> <span class='symbol'>meta-val</span>
               <span class='collection map'><span class='delimiter'>{</span><span class='delimiter'>}</span></span><span class='delimiter'>)</span></span>
        <span class='symbol'>body</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>if</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>&gt;</span> <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>count</span> <span class='symbol'>body</span><span class='delimiter'>)</span></span> <span class='number'>1</span><span class='delimiter'>)</span></span>
               <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>apply</span> <span class='symbol'>list</span> &apos;<span class='symbol'>do</span> <span class='symbol'>body</span><span class='delimiter'>)</span></span>
               <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>first</span> <span class='symbol'>body</span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>]</span></span>
    <span class='collection list'><span class='delimiter'>(</span><span class='symbol'>assoc</span> <span class='symbol'>opts</span> <span class='keyword'>:body</span> <span class='symbol'>body</span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span><span class='delimiter'>)</span></span></div></div></div></div><div class="footer" data-reactid="11"><!-- react-text: 12 -->Generated by <!-- /react-text --><a href="https://github.com/oakes/Dynadoc" target="_blank" data-reactid="13">Dynadoc</a></div></div></div></span>
        <script type="text/edn" id="initial-state">{:ns-meta nil, :var-sym parse-example, :type :clj, :nses [{:var-syms [deps load-deps], :type :clj, :sym boot-tools-deps.core} {:var-syms [clifn defclifn], :type :clj, :sym boot.cli} {:var-syms [tmppath tmptime output-dirs replace-task! sync! reset-fileset fileset-changed post-env! fileset-namespaces get-env with-pre-wrap not-by-path *warnings* deftask tmp-dir patch! user-dirs tmpget cleanup rm input-files fileset-reduce not-by-meta output-files bootignore add-cached-source with-post-wrap merge-env! tmpdir mv by-meta init! output-fileset get-checkouts gpg-decrypt by-name not-by-ext add-cached-asset tmp-get input-fileset new-fileset commit! not-by-re configure-repositories! by-ext mv-asset by-re *app-version* boot user-files set-env! task-options! file-filter temp-dir! mv-resource add-resource load-data-readers! tmp-path template json-parse reset-build! pre-env! fileset-diff new-build-at rebuild! ls *boot-script* watch-dirs add-source last-file-change fileset-removed cp *boot-opts* add-asset launch-nrepl yaml-generate yaml-parse empty-dir! add-cached-resource get-sys-env not-by-name set-sys-env! mv-source cache-dir! json-generate git-files touch fileset-added disable-task! tmp-dir! tmpfile with-pass-thru input-dirs tmp-file by-path tmp-time *boot-version* add-meta], :type :clj, :sym boot.core} {:var-syms [windows? sync! delete-empty-subdirs! guard hard-link delete-file path srcdir->outdir parent? tmpdir clean! copy-with-lastmod patch parent parent-seq copy-files *hard-link* name *include* move *exclude* *ignore* *sync-delete* file-seq relative-to lockfile file-seq-nofollow file? walk-file-tree patch-cp? empty-dir! watcher! split-path print-ex exists? sym-link dir? delete-all match-filter? tmpfile time-diff tmpfile-permissions copy-atomically keep-filters? tree-for], :type :clj, :sym boot.file} {:var-syms [windows? tree-diff map->FileSystemTree read-only skip-subtree link! merge-trees mkignores patch! mkvisitor ->FileSystemTree IToPath touch! path->segs ->path tmp-attrs open-opts continue mkparents! link-opts copy! tree-patch copy-opts write! mkjarfs delete! mktree], :type :clj, :sym boot.filesystem} {:var-syms [patch patch-result], :type :clj, :sym boot.filesystem.patch} {:var-syms [syntax-quote-fn unquote-splicing? quote-fn unquote? *resolve* resolve-symbol template syntax-quote defquote template-fn], :type :clj, :sym boot.from.backtick} {:var-syms [cli parse-opts summarize compile-option-specs], :type :clj, :sym boot.from.clojure.tools.cli} {:var-syms [sha-256 sha Digestible sha-1 md5 sha-384 -digest md2 sha-512 digest sha1 sha-224 algorithms *buffer-size*], :type :clj, :sym boot.from.digest} {:var-syms [cyan-bg magenta red-font bold-yellow-bg-font bold-green bold-yellow bold-red-bg bold-white-bg bold-cyan italic cyan-font strip-ansi bold-green-bg-font bold-red-bg-font visual-length black bold-black-bg bold bold-yellow-bg white-font bold-white bold-red red-bg cyan-bg-font bold-cyan-bg magenta-bg-font yellow-bg black-font yellow-bg-font white yellow bold-black-bg-font bold-green-bg bold-font inverse reset-font green-bg-font inverse-font white-bg-font green cyan black-bg-font green-font bold-magenta bold-red-font blue-bg-font bold-magenta-bg-font bold-cyan-font bold-white-bg-font blue-bg green-bg bold-blue-bg italic-font csi black-bg blue-font magenta-font yellow-font red-bg-font bold-yellow-font white-bg bold-cyan-bg-font magenta-bg bold-magenta-bg sgr bold-magenta-font red blue bold-black-font bold-blue-font bold-white-font bold-black bold-blue-bg-font bold-green-font bold-blue], :type :clj, :sym boot.from.io.aviso.ansi} {:var-syms [max-value-length format-columns write-rows max-length], :type :clj, :sym boot.from.io.aviso.columns} {:var-syms [*traditional* *fonts* format-exception *default-frame-filter* write-exception* *default-frame-rules* exception-dispatch demangle expand-stack-trace write-exception parse-exception analyze-exception], :type :clj, :sym boot.from.io.aviso.exception} {:var-syms [pretty-print format-exception pretty-print-stack-trace copy uncaught-exception-handler install-pretty-exceptions paste pretty-repl-caught pretty-pst], :type :clj, :sym boot.from.io.aviso.repl} {:var-syms [StringWriter flush-writer write into-string write-string writeln writef eol], :type :clj, :sym boot.from.io.aviso.writer} {:var-syms [feed-from flush exit-code done feed-from-string stream-to-string proc stream-to destroy read-line stream-to-out], :type :clj, :sym boot.from.me.raynes.conch} {:var-syms [format-cell table *style* table-str], :type :clj, :sym boot.from.table.core} {:var-syms [auto-resize-widths outer-border-length get-widths get-initial-widths ensure-valid-width *width* inner-border-length], :type :clj, :sym boot.from.table.width} {:var-syms [tag branch-current ls-tags clean? dirty? status last-commit describe ls-files make-gitignore-matcher], :type :clj, :sym boot.git} {:var-syms [gpg sign gpg-program signing-args sign-jar decrypt], :type :clj, :sym boot.gpg} {:var-syms [update-zip! spit-jar! jarentry spit-zip! dupe? update-jar!], :type :clj, :sym boot.jar} {:var-syms [normalize no-incoming choose topo-sort], :type :clj, :sym boot.kahnsort} {:var-syms [cli-opts parse-bootignore -main shebang? pr-boot-form emit], :type :clj, :sym boot.main} {:var-syms [prn-conflicts dep-conflicts safe-read-string compare-version resolved-versions sortable-version], :type :clj, :sym boot.pedantic} {:var-syms [sealed-classloader-fns with-worker apply-global-exclusions require-in copy-url classloader-resources resolve-release-versions resources pom-xml concat-merger jars-dep-graph eval-in* full-id with-eval-in worker-pod jar-entries* pom-xml-map dependency-pom-properties pod-pool pom-properties data resolve-dependency-jar dependency-pom-properties-map add-dependencies first-wins-merger standard-jar-exclusions destroy-pod canonical-id coord->map with-call-worker send! pom-properties-map canonical-coord unpack-jar this-pod make-pod extend-addable-classloader outdated with-eval-worker resolve-dependencies make-pod-cp pod-id non-caching-url-input-stream into-merger add-shutdown-hook! eval-fn-call pod-name with-invoke-in modifiable-classloader? with-call-in add-dependencies-in jar-entries seal-app-classloader jar-entries-memoized* call-in* classloader-hierarchy copy-resource resolve-nontransitive-dependencies default-dependencies eval-in-callee set-worker-pod! env set-this-pod! caller-namespace add-classpath set-data! with-invoke-worker dependency-loaded? apply-exclusions copy-dependency-jar-entries set-pod-id! map->coord standard-jar-mergers resource-last-modified resolve-dependency-jars jars-in-dep-order with-pod get-classpath pods get-pods eval-in-caller extract-ids set-pods! add-dependencies-worker shutdown-hooks lifecycle-pool], :type :clj, :sym boot.pod} {:var-syms [*default-dependencies* *default-middleware* launch-nrepl], :type :clj, :sym boot.repl} {:var-syms [sift-action read-pass print-fileset], :type :clj, :sym boot.task-helpers} {:var-syms [notify-method boot-logo get-themefiles audible-notify! visual-notify!], :type :clj, :sym boot.task-helpers.notify} {:var-syms [target notify help speak pom sift show web install push jar checkout javac with-cp war add-repo aot zip watch repl wait uber], :type :clj, :sym boot.task.built-in} {:var-syms [->TmpDir ->TmpFileSet add add-tmp map->TmpFileSet removed rm diff path add-cached ITmpFileSet mv hash dir bdir commit! added *hard-link* file time map->TmpDir CACHE_VERSION map->TmpFile state ITmpFile ls cp tmpfileset? ->TmpFile tmpfile? fileset-patch restrict-dirs id changed], :type :clj, :sym boot.tmpdir} {:var-syms [->TmpRegistry -mk! mkdir! mk! mark-delete-me! -get munged-file -init! get init! clean-delete-me! dir-id registry map->TmpRegistry unmk! make-file! tmp-file? -unmk! delete! ITmpRegistry -tmpfile?], :type :clj, :sym boot.tmpregistry} {:var-syms [deploy local run], :type :clj, :sym boot.user} {:var-syms [sh with-let dbug *verbosity* without-exiting exit-error with-err-str guard dotoseq extends-protocol with-rethrow with-semaphore dosh colorize?-system-default jarname do-while-let exit-ok dep-as-map bind-syms warn path->ns let-assert-keys read-string-all pp-str with-semaphore-noblock *sh-dir* with-resolve dbug* print-tree auto-flush *colorize?* fail print-ex map-as-dep pp* while-let warn-deprecated index-of info extract-ids], :type :clj, :sym boot.util} {:var-syms [->clj *to-pod* *from-pod* *for-eval*], :type :clj, :sym boot.xform} {:var-syms [type? get-namespace error-message elide-reader-meta missing-rename? resolve-invokeable-ns analyze-let with-core-macros var-meta desugar-ns-specs js-tag? analyze-map NUMERIC_SET analyze-record analyze-seq* constants-ns-sym resolve-alias *cljs-dep-set* resolve-var write-analysis-cache disallowing-ns* process-rewrite-form js-star-seg dep-has-global-exports? register-specs gen-user-ns *passes* has-extern?* get-expander-ns message parse-invoke *cljs-warning-handlers* disallowing-recur analyze-seq*-wrap confirm-bindings has-extern? foreign-dep? missing-rename-macro? missing-uses missing-use? with-warning-handlers es5-allowed analyze used? node-module-dep? parse-type gets check-rename-macros-inferring-missing *allow-ns* transit-write-opts forms-seq* infer-invoke *cljs-static-fns* array-types *check-alias-dupes* macro-ns-name *reload-macros* resolve-existing-var required? NOT_NATIVE *unchecked-arrays* IGNORE_SYM parse-invoke* *checked-arrays* aliasable-clj-ns? loaded-js-ns? analyze-vector transit-read-opts namespaces elide-analyzer-meta analyze-let-body get-col basic-validate-ns-spec *cljs-warnings* alias->type analyzed? analyze-deps array-type? dotted-symbol? *cljs-macros-is-classpath* locate-src ns-side-effects *allow-redef* analyze-fn-method-body infer-type parse-import-spec clj-ns->cljs-ns constant-value? dump-specs *fn-invoke-direct* use->require inferred-use-macros read-analysis-cache analyze-symbol confirm-var-exists analyze-keyword SENTINEL analyze-let-bindings munge-global-export *loop-lets* js-tag js-reserved *load-tests* requires-analysis? check-use-macros-inferring-missing load-core macroexpand-1* check-use-macros get-expander analyze-js-star build-dot-form js-star-interp *recur-frames* analyze-fn-methods-pass2* macroexpand-1 analyze-file resolve-macro-var analyze-let-binding-init infer-tag canonicalize-import-specs analyze-form-seq analyze-let-body* analyze-js-star* inferred-rename-macros parse-ns-error-msg missing-use-macro? analyzed resolve-symbol all-warn missing-renames resolve* *cljs-macros-path* load-mutex confirm-var-exist-warning unchecked-arrays? analyze-dot analyze-do-statements get-line analyze-do-statements* analyze-seq find-def-clash get-expander* no-warn allowing-redef fn-name-var munge-node-lib *load-macros* excluded? empty-env public-name? default-warning-handler resolve-ns-alias intern-macros BOOLEAN_OR_SEQ *macro-infer* gen-constant-id BOOLEAN_SYM cache-file macro-autoload-ns? get-tag implicit-nses valid-proto parse-ns normalize-js-tag analyze-list warning implicit-import? missing-use-macros rewrite-cljs-aliases analyze* -cljs-macros-loaded check-uses find-matching-method invoke-arg-type-validators *cljs-file* *file-defs* infer-if *verbose* analyze-js-value ns->module-type source-info wrapping-errors transit analyze-fn-method-param analyze-set numeric-type? ast? checked-arrays elide-env js-module-exists?* parse-require-spec analyze-wrap-meta ANY_SYM get-js-tag parse forms-seq *analyze-deps* analyze-let-bindings* analysis-error? replace-env-pass parse-ns-excludes analyze-fn-methods-pass2 core-name? get-let-tag specials resolve-macro-ns-alias check-invoke-arg-types confirm-ns default-namespaces *unchecked-if* canonicalize-specs confirm-var-exists-throw js-module-exists? analyze-form with-core-macros-file var-ast add-consts error invokeable-ns? *cljs-ns*], :type :clj, :sym cljs.analyzer} {:var-syms [emit-constants-table-to-file protocol-prefix emit-arguments-to-array compile-file* distinct-keys? munge compile-root get-define valid-define-value? find-source emit-cached-core emits-keyword emit-inferred-externs-to-file *lexical-renames* emit-let with-core-cljs find-root-sources cljs-reserved-file-names base-types resolve-type emit-variadic-fn-method js-reserved *recompiled* rename-to-js requires-compilation? emits emit-constant emit-constants-table get-first-ns-segment emit-fn-params munge-reserved emit-source fn-self-name load-libs compile-file macro-ns? munge-param-return find-ns-starts-with emit* checking-types? cljs-files-in emit-fn-method emit-comment hash-scope emit-apply-to emits-symbol falsey-constant? *source-map-data* mapped-types resolve-types cached-core *inputs* emit-str compiled-by-string truthy-constant? emitln url-path emit safe-test? emit-externs emit-source-map distinct-constants? emit-wrap shadow-depth], :type :clj, :sym cljs.compiler} {:var-syms [sort-by ITransientAssociative chunk-first m3-hash-int pr-str* tree-seq unchecked-remainder-int seq reduce contains? every? keep-indexed subs IFind MODULE_URIS take-last bit-set string-hash-cache-count qualified-keyword? -with-meta unchecked-subtract-int -iterator *print-namespace-maps* first native-satisfies? seq? -sorted-seq-from inst-ms iterate -empty ILookup -chunked-rest fn? -assoc keyword-identical? *print-err-fn* dissoc atom bit-shift-right *clojurescript-version* -first peek IKVReduce aget -write iter last namespace -conj = ITransientMap take vector? boolean IChunk bit-shift-left any? aclone vreset! chunk dec APersistentVector map < rest -drop-first boolean? -clone char? -reduce -count swap-vals! keep char mapcat unchecked-long m3-seed some? unchecked-negate symbol-identical? *command-line-args* reverse inst? bit-count sort unchecked-inc-int -compare map-indexed comp array-chunk bit-shift-right-zero-fill -as-transient simple-symbol? IIndexed disj IPrintWithWriter IVector IIterable cons floats pos? fnil nthrest *warn-on-infer* -find sequential? m3-mix-H1 prim-seq *print-level* shuffle hash-keyword find alength bit-xor unsigned-bit-shift-right neg? js-invoke m3-mix-K1 unchecked-float undefined? IMeta reduced? disj! -lookup float? ICloneable booleans int-array set? iterable? -pr-writer vary-meta INext is_proto_ ICounted IMapEntry <= MODULE_INFOS conj! -pop repeatedly reset-vals! IStack -remove-watch IVolatile remove * min -persistent! -nth pop! chunk-append *unchecked-arrays* IReversible reversible? -realized? -add-watch -deref-with-timeout conj -sorted-seq transduce -swap! *print-length* js-delete truth_ compare-and-set! array-seq interleave map? m3-C1 get identity into long double volatile? -key nfirst meta -kv-reduce IHash bit-and-not var? -comparator unchecked-add-int hash-ordered-coll IEquiv cycle -deref empty? short -chunked-first filterv hash quot unchecked-double ranged-iterator ITransientVector longs not= set-print-err-fn! string? es6-iterator m3-C2 *print-newline* unchecked-multiply-int chunk-rest double? vec *print-meta* -notify-watches int second IEditableCollection hash-combine > -name int? associative? unchecked-int js-keys inst-ms* keyword? array-iter -rseq unchecked-multiply even? es6-iterator-seq unchecked-dec Inst double-array spread rseq IReset IEmptyableCollection *print-fn-bodies* float IRecord concat IDerefWithTimeout symbol to-array-2d mod ISet pop IPending -entry-key dissoc! indexed? - -equiv assoc! reduce-kv reset! Fn ffirst counted? assoc-in bit-test ISwap zero? simple-keyword? *main-cli-fn* -assoc-n unchecked-dec-int persistent! set-print-fn! nnext not-every? rem ifind? some INamed IReduce neg-int? drop js-obj ITransientCollection nth sorted? nil? split-at not-native bit-and bounded-count update list* update-in ensure-reduced instance? mix-collection-hash unchecked-add transformer-iterator not -vreset! with-meta unreduced record? type identical? -namespace unchecked-divide-int *out* hash-string set-validator! ident? -meta swap! -chunked-next unchecked-subtract IMap cloneable? qualified-ident? hash-string* true? array -peek ISeq empty volatile! / bit-or m3-fmix vector >= drop-last object? not-empty partition DEMUNGE_PATTERN IAssociative bit-flip long-array ISeqable js-mod integer? mapv infinite? ISequential equiv-map object-array seq-iter IChunkedSeq -next flatten -dissoc doubles -contains-key? ifn? IAtom nat-int? IWatchable subvec -pop! partial chunked-seq? replicate reduced ITransientSet unchecked-byte every-pred missing-protocol load-file distinct? pos-int? unchecked-short odd? reduceable? string-hash-cache inc type->str bit-clear filter -assoc-n! IWithMeta list + aset int-rotate-left keyword *ns* *assert* ICollection chars next ASeq IFn -reset! -rest nil-iter false? *print-readably* ints some-fn *flush-on-newline* to-array list? array? simple-ident? clone bit-not byte max IComparable == count -disjoin! *loaded-libs* apply add-to-string-hash-cache IChunkedNext interpose deref assoc transient -disjoin chunk-cons drop-while IWriter *print-fn* compare complement -assoc! *print-dup* string-iter IDeref sequence constantly chunked-seq ISorted make-array shorts *unchecked-if* enable-console-print! -flush completing unchecked-negate-int hash-unordered-coll repeat unchecked-inc nthnext get-validator number? -conj! chunk-next not-any? into-array -hash qualified-symbol? -dissoc! chunk-buffer seqable? symbol? m3-hash-unencoded-chars unchecked-char system-time -invoke coll? get-in fnext IList -val bytes -seq], :type :cljs, :sym cljs.core} {:var-syms [ensure with-compiler-env default-compiler-env *compiler*], :type :clj, :sym cljs.env} {:var-syms [parse-extern-node get-type parse-externs externs-map annotate index-externs get-type*], :type :clj, :sym cljs.externs} {:var-syms [zip-file goog-dependencies load-foreign-library find-js-jar find-js-fs find-js-resources to-url -requires build-index jar-entry-names find-js-classpath goog-dependencies* -provides native-node-modules IJavaScript -source lib-spec-merge dependency-order-visit js-dependency-index -relative-path load-foreign-library* load-library -url find-url -foreign? get-file load-library* jar-entry-names* -closure-lib? library-dependencies find-classpath-lib parse-js-ns dependency-order], :type :clj, :sym cljs.js-deps} {:var-syms [pprint get-pretty-writer *print-suppress-namespaces* char-code *print-pretty* *print-pprint-dispatch* pprint-newline float? pprint-tab pprint-set print-table set-pprint-dispatch fresh-line pprint-indent *print-radix* IPrettyFlush cl-format *print-miser-width* write -ppflush *print-right-margin* write-out *print-base*], :type :cljs, :sym cljs.pprint} {:var-syms [print-doc], :type :cljs, :sym cljs.repl} {:var-syms [update-result encode invert-reverse-map relativize-path decode seg->map source-compare decode-reverse lines->segs merge-source-maps update-reverse-result indexed-sources encode* seg-combine], :type :clj, :sym cljs.source-map} {:var-syms [chars64 encode int->char decode char->int], :type :clj, :sym cljs.source-map.base64} {:var-syms [encode-val encode vlq-continuation-bit vlq-base-mask bit-shift-right-zero-fill decode vlq-base-shift from-vlq-signed to-vlq-signed vlq-base], :type :clj, :sym cljs.source-map.base64-vlq} {:var-syms [form nilable-impl *recursion-limit* *coll-error-limit* explain-printer Specize alt-impl def-impl *explain-out* regex-spec-impl merge-spec-impl explain-data* MAX_INT check-asserts assert* inst-in-range? and-spec-impl describe* map-spec-impl explain with-gen* or-spec-impl *fspec-iterations* Spec unform valid? gen nonconforming unform* abbrev regex? int-in-range? spec? registry rep+impl exercise explain-data tuple-impl multi-spec-impl conform gen* fspec-impl *coll-check-limit* get-spec every-impl spec-impl invalid? amp-impl cat-impl explain-str *compile-asserts* with-gen conform* check-asserts? rep-impl describe explain-out specize* maybe-impl explain*], :type :cljs, :sym cljs.spec.alpha} {:var-syms [quick-check for-all* delay-impl cat gen-for-pred], :type :cljs, :sym cljs.spec.gen.alpha} {:var-syms [read-uuid valid-js-literal-key? read-inst read-queue *cljs-data-readers* ->JSValue read-js], :type :clj, :sym cljs.tagged-literals} {:var-syms [output-directory windows? *clojurescript-version* boolean? file-or-resource distinct-by path normalize-path clojurescript-version ext content-sha valid-js-id-start? ns->relpath get-name debug-prn-mutex map-merge to-target-file mkdirs compile-if url? module-file-seq conjunction-str suggestion path-seq compiled-by-version measure ns->source last-modified debug-prn file? unknown-opts levenshtein-distance filename to-path topo-sort munge-path build-options changed? relative-name], :type :clj, :sym cljs.util} {:var-syms [primitives-classnames +' decimal? restart-agent sort-by macroexpand ensure chunk-first eduction tree-seq unchecked-remainder-int seq reduce when-first find-ns get-thread-bindings contains? every? proxy-mappings keep-indexed cond->> subs ref-min-history set take-last bit-set reader-conditional gen-class qualified-keyword? while ->Eduction butlast satisfies? line-seq unchecked-subtract-int *print-namespace-maps* take-nth first re-groups seq? dec' ns-unmap println-str with-bindings* inst-ms iterator-seq iterate slurp newline short-array fn? doall prefers enumeration-seq dedupe dissoc atom import bit-shift-right print-method peek aget pvalues bound-fn vswap! last pr namespace push-thread-bindings bases = dosync remove-ns take vector? thread-bound? send-via boolean bit-shift-left any? find-var rand-int aclone vreset! chunk dec future-call resultset-seq struct map juxt ns-publics < *source-path* with-loading-context test rest ex-data compile isa? boolean? .. munge delay set-error-mode! re-seq char? make-hierarchy set-agent-send-executor! swap-vals! keep char mapcat unchecked-long aset-long some? unchecked-negate gen-interface *command-line-args* reverse inst? range sort -cache-protocol-fn unchecked-inc-int map-indexed with-bindings rand-nth comp await spit future-done? *read-eval* dorun simple-symbol? disj *2 eval cons refer print-dup -reset-methods floats pos? fnil merge-with nthrest load if-not *verbose-defrecords* sequential? *print-level* shuffle boolean-array find alength bit-xor deliver doseq unsigned-bit-shift-right neg? var-set unchecked-float pmap error-mode num reduced? disj! float? aset-float deftype bean booleans ns-unalias when-let int-array set? inc' cat StackTraceElement->vec *suppress-read* flush take-while vary-meta <= alter -' if-some conj! repeatedly zipmap reset-vals! alter-var-root biginteger remove * re-pattern min pop! chunk-append prn-str with-precision format reversible? shutdown-agents conj bound? transduce lazy-seq *print-length* *file* compare-and-set! *use-context-classloader* await1 let ref-set pop-thread-bindings interleave printf map? -> defstruct *err* get doto identity into areduce long double volatile? definline nfirst meta find-protocol-impl bit-and-not *default-data-reader-fn* var? method-sig unchecked-add-int unquote-splicing hash-ordered-coll future reset-meta! cycle fn seque empty? short definterface filterv hash quot ns-aliases read unchecked-double key longs not= string? uri? aset-double unchecked-multiply-int chunk-rest pcalls *allow-unresolved-vars* remove-all-methods ns-resolve as-> aset-boolean trampoline double? when-not *1 vec *print-meta* when int map-entry? ns-refers rand second vector-of hash-combine > replace int? associative? unchecked-int set-error-handler! inst-ms* keyword? force bound-fn* namespace-munge group-by prn extend unchecked-multiply some->> default-data-readers ->VecSeq even? unchecked-dec Inst tagged-literal? double-array in-ns create-ns re-matcher defn ref bigint extends? promise aset-char rseq construct-proxy agent-errors *compile-files* *math-context* float pr-str concat aset-short set-agent-send-off-executor! ns symbol to-array-2d mod amap pop use unquote declare dissoc! reductions aset-byte indexed? ref-history-count - assoc! hash-set reduce-kv or cast reset! name ffirst sorted-set counted? byte-array tagged-literal println extend-type macroexpand-1 assoc-in char-name-string bit-test defmethod EMPTY-NODE time memoize alter-meta! future? zero? simple-keyword? require unchecked-dec-int persistent! nnext add-watch not-every? class? rem agent-error some future-cancelled? memfn neg-int? struct-map drop *data-readers* nth sorted? nil? extend-protocol split-at *e load-reader random-sample cond-> dotimes select-keys bit-and bounded-count update list* reify update-in prefer-method aset-int *clojure-version* ensure-reduced *' instance? with-open mix-collection-hash re-find run! val defonce unchecked-add loaded-libs ->Vec bytes? not with-meta unreduced the-ns record? type identical? unchecked-divide-int ns-name max-key *unchecked-math* defn- *out* file-seq agent ns-map set-validator! ident? defprotocol swap! vals unchecked-subtract *warn-on-reflection* sorted-set-by sync qualified-ident? assert *compile-path* true? release-pending-sends print empty remove-method *in* print-ctor letfn volatile! / read-line reader-conditional? bit-or clear-agent-errors vector proxy-super >= drop-last not-empty distinct partition loop add-classpath bit-flip long-array descendants merge accessor integer? mapv partition-all partition-by numerator object-array with-out-str condp derive load-string special-symbol? ancestors subseq error-handler gensym cond ratio? delay? intern print-simple flatten doubles halt-when with-in-str remove-watch ex-info ifn? some-> nat-int? proxy-name ns-interns all-ns find-protocol-method subvec for binding partial chunked-seq? find-keyword replicate min-key reduced char-escape-string re-matches array-map unchecked-byte with-local-vars ns-imports send-off defmacro every-pred keys rationalize load-file distinct? pos-int? extenders unchecked-short methods odd? ->ArrayChunk float-array *3 alias frequencies read-string proxy rsubseq inc get-method with-redefs uuid? bit-clear filter locking list + split-with aset ->VecNode keyword *ns* destructure *assert* defmulti chars str next hash-map if-let underive ref-max-history Throwable->map false? *print-readably* ints class some-fn case *flush-on-newline* to-array bigdec list? simple-ident? bit-not io! xml-seq byte max == *agent* lazy-cat comment parents count supers *fn-loader* sorted-map-by apply interpose deref assoc rational? transient clojure-version chunk-cons comparator sorted-map send drop-while proxy-call-with-super realized? char-array resolve compare complement *compiler-options* *print-dup* defrecord with-redefs-fn sequence constantly get-proxy-class make-array shorts completing update-proxy unchecked-negate-int hash-unordered-coll repeat unchecked-inc *reader-resolver* nthnext and create-struct get-validator number? await-for chunk-next print-str not-any? into-array qualified-symbol? init-proxy chunk-buffer seqable? symbol? when-some unchecked-char ->> future-cancel var-get commute coll? get-in fnext denominator bytes refer-clojure], :type :clj, :sym clojure.core} {:var-syms [Pub reduce remove> timeout unsub* admix* unmix* mix pub take unsub-all* <! map Mux mapcat> buffer close! offer! chan solo-mode* tap go admix promise-chan unique muxch* solo-mode transduce onto-chan to-chan dropping-buffer untap-all into >!! alt! pipeline sub go-loop map> pipe unmix filter< sub* remove< alt!! untap* <!! toggle untap-all* sliding-buffer partition Mult merge partition-by unsub-all >! unmix-all* split unmix-all filter> tap* untap alts! unsub poll! thread map< fn-handler do-alts pipeline-blocking pipeline-async Mix toggle* mult thread-call alts!! mapcat< ioc-alts! unblocking-buffer? do-alt put! take!], :type :clj, :sym clojure.core.async} {:var-syms [->PromiseBuffer ->DroppingBuffer dropping-buffer fixed-buffer ->FixedBuffer sliding-buffer ->SlidingBuffer promise-buffer], :type :clj, :sym clojure.core.async.impl.buffers} {:var-syms [cleanup chan box MMC abort assert-unlock ->ManyToManyChannel], :type :clj, :sym clojure.core.async.impl.channels} {:var-syms [counted-thread-factory processors], :type :clj, :sym clojure.core.async.impl.concurrent} {:var-syms [executor run], :type :clj, :sym clojure.core.async.impl.dispatch} {:var-syms [thread-pool-executor], :type :clj, :sym clojure.core.async.impl.exec.threadpool} {:var-syms [index-state-machine ->PopTry EXCEPTION-FRAMES block-references reads-from index-block map->Case map->InstanceInterop add-block instruction? ->RawCode let-binding-to-ssa map->CondBr map->Const ->Call ->Jmp ->CondBr map->PushTry count-persistent-values get-binding gen-plan -item-to-ssa ->Case get-block id-for-inst index-instruction pdebug writes-to ->Dot map->CustomTerminator terminator-code set-block ->CatchHandler STATE-IDX ->PushTry mark-transitions ->Fn map->CatchHandler ->Return aset-object run-passes IEmittableInstruction map->Call ITerminator map->Fn emit-instruction IInstruction map->Dot make-env propagate-recur terminate-block ->InstanceInterop map->PopTry persistent-value? propagate-transitions assoc-in-plan run-state-machine-wrapped push-alter-binding aset-all! debug parse-to-state-machine get-plan FN-IDX aget-object return-chan all pop-binding ->EndFinally nested-go? ->Recur add-instruction no-op passes push-binding ->CustomTerminator BINDINGS-IDX map->Return item-to-ssa map->EndFinally async-custom-terminators ->StaticCall map->RawCode CURRENT-EXCEPTION emit-hinted ->Const map->StaticCall print-plan run-state-machine get-in-plan update-in-plan map->Recur map->Jmp finished? USER-START-IDX put! take! var-name state-machine VALUE-IDX], :type :clj, :sym clojure.core.async.impl.ioc-macros} {:var-syms [mutex], :type :clj, :sym clojure.core.async.impl.mutex} {:var-syms [remove! close-buf! close! Handler blockable? active? Buffer full? add! lock-id exec Executor add!* ReadPort Channel closed? UnblockingBuffer MAX-QUEUE-SIZE commit put! take! WritePort], :type :clj, :sym clojure.core.async.impl.protocols} {:var-syms [->TimeoutQueueEntry timeout timeout-daemon TIMEOUT_RESOLUTION_MS], :type :clj, :sym clojure.core.async.impl.timers} {:var-syms [defcache clear-soft-cache! make-reference ->FnCache ->SoftCache soft-cache-factory ->TTLCache has? evict miss lookup hit through ttl-cache-factory lu-cache-factory ->LIRSCache ->LRUCache ->BasicCache lirs-cache-factory basic-cache-factory CacheProtocol seed fifo-cache-factory ->FIFOCache ->LUCache lru-cache-factory], :type :clj, :sym clojure.core.cache} {:var-syms [memo-ttl ->PluggableMemoization memo memoized? lu fifo memo-unwrap through* memo-fifo memo-swap! ->RetryingDelay lru build-memoizer snapshot ttl memo-lu memo-clear! memo-lru], :type :clj, :sym clojure.core.memoize} {:var-syms [IKVReduce CollReduce coll-reduce internal-reduce InternalReduce kv-reduce], :type :clj, :sym clojure.core.protocols} {:var-syms [stop-server repl-init start-server start-servers stop-servers repl-read *session* repl], :type :clj, :sym clojure.core.server} {:var-syms [diff equality-partition EqualityPartition diff-similar Diff], :type :clj, :sym clojure.data} {:var-syms [pad-length encode decode! dec-length decode enc-length encode! encoding-transfer decoding-transfer], :type :clj, :sym clojure.data.codec.base64} {:var-syms [pprint -write read-json read-str read json-str write-str pprint-json JSONWriter write write-json print-json], :type :clj, :sym clojure.data.json} {:var-syms [->PersistentPriorityMap priority-map-by apply-keyfn priority-map-keyfn priority-map-keyfn-by priority-map], :type :clj, :sym clojure.data.priority-map} {:var-syms [read read-string], :type :clj, :sym clojure.edn} {:var-syms [validated read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym clojure.instant} {:var-syms [default-streams-impl make-output-stream make-parents delete-file input-stream make-writer as-relative-path copy as-file output-stream make-reader Coercions file make-input-stream IOFactory resource writer as-url reader], :type :clj, :sym clojure.java.io} {:var-syms [sh *sh-dir* with-sh-dir *sh-env* with-sh-env], :type :clj, :sym clojure.java.shell} {:var-syms [main with-bindings stack-element-str repl-caught repl-exception repl-read load-script skip-if-eol skip-whitespace root-cause repl-requires demunge with-read-known repl repl-prompt], :type :clj, :sym clojure.main} {:var-syms [pprint simple-dispatch get-pretty-writer *print-suppress-namespaces* *print-pretty* *print-pprint-dispatch* pprint-newline code-dispatch print-length-loop pprint-tab pprint-logical-block print-table pp set-pprint-dispatch fresh-line formatter-out formatter pprint-indent *print-radix* cl-format *print-miser-width* write *print-right-margin* write-out with-pprint-dispatch *print-base*], :type :clj, :sym clojure.pprint} {:var-syms [->Field ->Method TypeReference reflect map->Field map->Method typename ->JavaReflector ->AsmReflector resolve-class flag-descriptors do-reflect ClassResolver Reflector ->Constructor map->Constructor type-reflect], :type :clj, :sym clojure.reflect} {:var-syms [source-fn doc stack-element-str find-doc dir pst dir-fn source set-break-handler! root-cause demunge thread-stopper apropos], :type :clj, :sym clojure.repl} {:var-syms [union map-invert join select intersection superset? index subset? rename rename-keys project difference], :type :clj, :sym clojure.set} {:var-syms [form & nilable-impl *recursion-limit* *coll-error-limit* fspec explain-printer Specize every keys* alt-impl def-impl *explain-out* regex-spec-impl merge-spec-impl explain-data* check-asserts assert* inst-in-range? nilable and-spec-impl describe* map-spec-impl coll-of cat * explain with-gen* or-spec-impl *fspec-iterations* Spec unform valid? gen every-kv int-in alt nonconforming unform* abbrev regex? int-in-range? or spec? registry rep+impl exercise-fn exercise multi-spec explain-data tuple-impl multi-spec-impl tuple conform gen* fspec-impl assert ? *coll-check-limit* merge get-spec conformer every-impl spec keys spec-impl + invalid? amp-impl map-of cat-impl explain-str *compile-asserts* with-gen conform* check-asserts? rep-impl double-in inst-in describe explain-out and specize* def maybe-impl explain* fdef], :type :clj, :sym clojure.spec.alpha} {:var-syms [uuid gen-for-pred lazy-prim set one-of any-printable vector-distinct boolean string-alphanumeric map delay simple-type char bind symbol-ns any lazy-prims cat double char-alpha int return gen-for-name symbol quick-check char-alphanumeric choose for-all* string-ascii frequency double* generate delay-impl lazy-combinators tuple string vector large-integer keyword-ns not-empty elements sample list large-integer* keyword hash-map ratio such-that fmap char-ascii simple-type-printable lazy-combinator bytes], :type :clj, :sym clojure.spec.gen.alpha} {:var-syms [print-stack-trace print-trace-element print-cause-trace e root-cause print-throwable], :type :clj, :sym clojure.stacktrace} {:var-syms [ends-with? capitalize reverse join replace-first starts-with? escape last-index-of re-quote-replacement includes? replace split-lines lower-case trim-newline upper-case split trimr index-of trim triml blank?], :type :clj, :sym clojure.string} {:var-syms [ends-with? capitalize reverse join replace-first starts-with? escape last-index-of includes? replace split-lines lower-case trim-newline upper-case split trimr index-of trim triml blank?], :type :cljs, :sym clojure.string} {:var-syms [do-template apply-template], :type :clj, :sym clojure.template} {:var-syms [are test-all-vars test-var do-report run-all-tests assert-any testing-contexts-str file-position testing join-fixtures set-test get-possibly-unbound-var assert-expr report compose-fixtures with-test *stack-trace-depth* is *report-counters* *load-tests* deftest assert-predicate with-test-out function? deftest- test-vars try-expr successful? use-fixtures inc-report-counter testing-vars-str *testing-contexts* test-ns run-tests *testing-vars* *test-out* *initial-report-counters*], :type :clj, :sym clojure.test} {:var-syms [macroexpand valid-binding-symbol? analyze-let analyze-map parse-def parse-quote parse-new analyze-fn-method parse-invoke analyze parse-dot parse-do analyze-const parse-loop* analyze-vector var? parse-if -analyze-form create-var parse-try analyze-symbol macroexpand-1 analyze-body parse-letfn* parse-catch analyze-seq parse-recur empty-env analyze-in-env parse-fn* validate-bindings parse-let* parse-throw analyze-set -parse parse wrapping-meta parse-set! specials analyze-form parse-var], :type :clj, :sym clojure.tools.analyzer} {:var-syms [update-children postwalk children walk prewalk children* cycling ast->eav update-children-reduced nodes], :type :clj, :sym clojure.tools.analyzer.ast} {:var-syms [ensure deref-env *env* with-env], :type :clj, :sym clojure.tools.analyzer.env} {:var-syms [analyze-ns parse-case* global-env analyze qualify-arglists parse-reify* analyze+eval analyze-method-impls desugar-symbol create-var run-passes parse-monitor-enter parse-import* build-ns-map macroexpand-1 desugar-host-expr parse-deftype* parse-opts+methods -deftype default-passes empty-env update-ns-map! macroexpand-all scheduled-default-passes parse default-passes-opts parse-monitor-exit specials ->ExceptionThrown], :type :clj, :sym clojure.tools.analyzer.jvm} {:var-syms [unbox static-methods members special-arrays static-field primitive? instance-methods numeric? instance-method static-members wider-tag static-method wider-primitive prim-or-obj ns->relpath try-best-match maybe-class instance-members maybe-class-from-string box array-class ns-url members* subsumes? wider-tag* name-matches? convertible? instance-field prim-interface inline? tag-match? maybe-class-literal specials macro? wider-than object-members], :type :clj, :sym clojure.tools.analyzer.jvm.utils} {:var-syms [schedule-passes satisfies-affected? schedule group compile-passes schedule* calculate-deps desugar-deps maybe-looping-pass collapse], :type :clj, :sym clojure.tools.analyzer.passes} {:var-syms [add-binding-atom], :type :clj, :sym clojure.tools.analyzer.passes.add-binding-atom} {:var-syms [cleanup], :type :clj, :sym clojure.tools.analyzer.passes.cleanup} {:var-syms [constant-lift], :type :clj, :sym clojure.tools.analyzer.passes.constant-lifter} {:var-syms [elides elide-meta replace-meta get-elides -elide-meta], :type :clj, :sym clojure.tools.analyzer.passes.elide-meta} {:var-syms [emit-bindings -emit-form emit-form -emit-form* emit-hygienic-form], :type :clj, :sym clojure.tools.analyzer.passes.emit-form} {:var-syms [-analyze-host-expr analyze-host-expr maybe-static-field maybe-instance-method analyze-host-call maybe-instance-field analyze-host-field maybe-static-method], :type :clj, :sym clojure.tools.analyzer.passes.jvm.analyze-host-expr} {:var-syms [annotate-host-info], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-host-info} {:var-syms [annotate-loops check-recur -check-recur -loops], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-loops} {:var-syms [-annotate-tag annotate-tag], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-tag} {:var-syms [if-let-box boxed? -box box], :type :clj, :sym clojure.tools.analyzer.passes.jvm.box} {:var-syms [classify-invoke], :type :clj, :sym clojure.tools.analyzer.passes.jvm.classify-invoke} {:var-syms [constant-lift constant-lift*], :type :clj, :sym clojure.tools.analyzer.passes.jvm.constant-lifter} {:var-syms [-emit-form emit-form -emit-form* class->str emit-hygienic-form class->sym], :type :clj, :sym clojure.tools.analyzer.passes.jvm.emit-form} {:var-syms [fix-case-test], :type :clj, :sym clojure.tools.analyzer.passes.jvm.fix-case-test} {:var-syms [-infer-tag infer-tag =-arglists?], :type :clj, :sym clojure.tools.analyzer.passes.jvm.infer-tag} {:var-syms [validate-tag validate-call validate validate-interfaces -validate], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate} {:var-syms [find-mismatches dirty -validate-loop-locals validate-loop-locals -validate-loop-locals* -cleanup-dirty-nodes], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate-loop-locals} {:var-syms [validate-recur], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate-recur} {:var-syms [warn-on-reflection warn], :type :clj, :sym clojure.tools.analyzer.passes.jvm.warn-on-reflection} {:var-syms [-merge-source-info source-info], :type :clj, :sym clojure.tools.analyzer.passes.source-info} {:var-syms [preserving-raw-forms trim -trim], :type :clj, :sym clojure.tools.analyzer.passes.trim} {:var-syms [normalize uniquify-locals* -uniquify-locals *locals-frame* uniquify-binding *locals-counter* uniquify-locals-around uniquify-locals uniquify], :type :clj, :sym clojure.tools.analyzer.passes.uniquify} {:var-syms [warn-earmuff], :type :clj, :sym clojure.tools.analyzer.passes.warn-earmuff} {:var-syms [type? ctx boolean? mapv' rseqv protocol-node? select-keys' -source-info classify reference? update-vals resolve-sym private? constant? regex? dynamic? compile-if into! const-val dissoc-env update-kv record? butlast+last obj? source-info mmerge resolve-ns update-keys arglist-for-arity macro? merge'], :type :clj, :sym clojure.tools.analyzer.utils} {:var-syms [cli parse-opts summarize get-default-options format-lines make-summary-part], :type :clj, :sym clojure.tools.cli} {:var-syms [resolve-deps make-classpath], :type :clj, :sym clojure.tools.deps.alpha} {:var-syms [-main], :type :clj, :sym clojure.tools.deps.alpha.makecp} {:var-syms [manifest-type manifest-types detect-manifest coord-paths coord-type compare-versions dep-id coord-deps], :type :clj, :sym clojure.tools.deps.alpha.providers} {:var-syms [read-deps], :type :clj, :sym clojure.tools.deps.alpha.reader} {:var-syms [map-keys], :type :clj, :sym clojure.tools.deps.alpha.util.coll} {:var-syms [exclusions->data make-session make-local-repo remote-repo default-local-repo dep->data console-listener ->CustomProvider the-system standard-repos coord->artifact], :type :clj, :sym clojure.tools.deps.alpha.util.maven} {:var-syms [immediate-dependencies remove-edge depends? depend immediate-dependents set-conj remove-node ->MapDependencyGraph transitive-dependents-set topo-comparator transitive-dependencies map->MapDependencyGraph DependencyGraph topo-sort transitive-dependents nodes graph DependencyGraphUpdate remove-all dependent? transitive-dependencies-set], :type :clj, :sym clojure.tools.namespace.dependency} {:var-syms [add-files remove-files read-file-ns-decl clojure-file?], :type :clj, :sym clojure.tools.namespace.file} {:var-syms [find-namespaces-in-jarfile find-namespaces-in-dir find-ns-decls-in-jarfile read-ns-decl-from-jarfile-entry find-ns-decls find-clojure-sources-in-dir clojure-sources-in-jar find-namespaces find-ns-decls-in-dir], :type :clj, :sym clojure.tools.namespace.find} {:var-syms [ns-decl? deps-from-ns-decl read-ns-decl comment?], :type :clj, :sym clojure.tools.namespace.parse} {:var-syms [add tracker remove], :type :clj, :sym clojure.tools.namespace.track} {:var-syms [*read-eval* *suppress-read* *default-data-reader-fn* read read-symbol default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* read-regex syntax-quote read-string map-func], :type :clj, :sym clojure.tools.reader} {:var-syms [default-uuid-reader validated clojure.tools.reader.default_data_readers.proxy$java.lang.ThreadLocal$ff19274a read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym clojure.tools.reader.default-data-readers} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern throwing-reader ratio-pattern], :type :clj, :sym clojure.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :clj, :sym clojure.tools.reader.impl.errors} {:var-syms [inspect inspect*], :type :clj, :sym clojure.tools.reader.impl.inspect} {:var-syms [whitespace? char numeric? make-var second' desugar-meta <=clojure-1-7-alpha5 ex-info? newline? namespace-keys compile-when], :type :clj, :sym clojure.tools.reader.impl.utils} {:var-syms [ReaderCoercer indexing-push-back-reader log-source* merge-meta ->StringReader to-pbr to-rdr Reader source-logging-push-back-reader unread peek-char push-back-reader IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line ->PushbackReader PushbackReaderCoercer string-push-back-reader log-source ->SourceLoggingPushbackReader ->InputStreamReader line-start? input-stream-push-back-reader source-logging-reader? IndexingReader get-line-number input-stream-reader ->IndexingPushbackReader], :type :clj, :sym clojure.tools.reader.reader-types} {:var-syms [postwalk keywordize-keys walk prewalk-replace stringify-keys prewalk postwalk-demo prewalk-demo macroexpand-all postwalk-replace], :type :clj, :sym clojure.walk} {:var-syms [walk postwalk prewalk keywordize-keys stringify-keys prewalk-replace postwalk-replace], :type :cljs, :sym clojure.walk} {:var-syms [prefix-placeholder parse-context cache-context], :type :clj, :sym compliment.context} {:var-syms [completions sort-by-length documentation ensure-ns all-files], :type :clj, :sym compliment.core} {:var-syms [defsource all-sources], :type :clj, :sym compliment.sources} {:var-syms [static? static-members-cache classname-doc static-members populate-members-cache update-static-cache members-doc members-cache class-member-symbol? members-candidates populate-static-members-cache static-members-candidates get-all-members camel-case-matches? doc-method-parameters resolve-static-member update-cache create-members-doc type-to-pretty-string static-member-doc try-get-object-class static-member-symbol?], :type :clj, :sym compliment.sources.class-members} {:var-syms [qualified-candidates candidates aliased-candidates namespace-alias-candidates], :type :clj, :sym compliment.sources.keywords} {:var-syms [parse-binding let-like-forms extract-local-bindings candidates doseq-like-forms bindings-from-context defn-like-forms], :type :clj, :sym compliment.sources.local-bindings} {:var-syms [doc nscl-matches? candidates nscl-symbol? all-classes-short-names imported-classes], :type :clj, :sym compliment.sources.namespaces-and-classes} {:var-syms [try-get-ns-from-context var-symbol? doc get-scope-and-prefix candidates dash-matches? generate-docstring], :type :clj, :sym compliment.sources.ns-mappings} {:var-syms [doc candidates inside-resource-call?], :type :clj, :sym compliment.sources.resources} {:var-syms [first-item-in-list? doc literal-candidates candidates], :type :clj, :sym compliment.sources.special-forms} {:var-syms [android-vm? resolve-namespace fuzzy-matches? project-resources classes-on-classpath fuzzy-matches-no-skip? resolve-class defmemoized namespaces-on-classpath *extra-metadata*], :type :clj, :sym compliment.utils} {:var-syms [chan <!! put!], :type :clj, :sym dynadoc.aliases} {:var-syms [dynadoc], :type :clj, :sym dynadoc.boot} {:var-syms [var-sym->url spec->html example->html init-editor expandable-section ns-sym->url sidebar var->html page-url update-link export-form export source->html app init-example-editor], :type :clj, :sym dynadoc.common} {:var-syms [print-server handler page-state get-clj-vars dev-start get-cljs-nses-and-vars-dynamically -main get-clj-nses get-examples var-map->vars get-cljs-nses-and-vars start *options public-files get-cljs-vars page export *web-server get-cljs-nses get-clj-var-info], :type :clj, :sym dynadoc.core} {:var-syms [defexample registry-ref parse-example defexamples parse-val parse-ns defexample* parse-keys defexamples*], :type :clj, :sym dynadoc.example} {:var-syms [read-cljs-file get-cljs-arglists get-cljs-nses-and-vars], :type :clj, :sym dynadoc.static} {:var-syms [form->serializable parse-uri flatten-vals cli-options process-example], :type :clj, :sym dynadoc.utils} {:var-syms [*cljs-info watch-request *channel->uri init-watcher!], :type :clj, :sym dynadoc.watch} {:var-syms [when-resolves], :type :clj, :sym dynapath.defaults} {:var-syms [can-read? DynamicClasspath add-classpath-url can-add? base-readable-addable-classpath classpath-urls], :type :clj, :sym dynapath.dynamic-classpath} {:var-syms [all-classpath-urls addable-classpath? add-classpath-url readable-classpath? classpath-urls], :type :clj, :sym dynapath.util} {:var-syms [thunk-timeout uglify-time-unit], :type :clj, :sym eval-soup.clojail} {:var-syms [wrap-security code->results wrap-timeout eval_soup.core.proxy$java.lang.SecurityManager$ff19274a with-security], :type :clj, :sym eval-soup.core} {:var-syms [process-handler process-paths extract-paths-by-type created? watch! stop! deleted? remove-duplicate-paths file? remove-children-paths process-context directory? modified? catch-errors], :type :clj, :sym hawk.core} {:var-syms [standard-watch-event-kinds polling-watcher-impl barbary-watch-event-kinds stop! new-watcher barbary-watcher-impl sensitivity-watch-event-modifiers Watcher java-watcher-impl take! register!], :type :clj, :sym hawk.watcher} {:var-syms [line->segments tag->hiccup line->html code->hiccup split-lines code->html line->hiccup tags-for-line->hiccup tag->html escape-html-str tags-for-line->html structurize-hiccup escape-html-char parse-lines], :type :clj, :sym html-soup.core} {:var-syms [night nightlight sandbox], :type :clj, :sym nightlight.boot} {:var-syms [options print-server handler form->serializable dev-start max-file-size -main cli-options start wrap-auth pref-file read-state file-node delete-parents-recursively! web-server], :type :clj, :sym nightlight.core} {:var-syms [create-pipes remove-returns state pipe-into-console! repl-request start-repl-thread!], :type :clj, :sym nightlight.repl} {:var-syms [file-content watcher channels cljs-info init-cljs-info watch-request], :type :clj, :sym nightlight.watch} {:var-syms [ns-tracker], :type :clj, :sym ns-tracker.core} {:var-syms [dependent seq-union dependencies remove-key depends? depend dependents graph remove-all], :type :clj, :sym ns-tracker.dependency} {:var-syms [deps-from-ns-decl], :type :clj, :sym ns-tracker.nsdeps} {:var-syms [in-ns-decl? read-in-ns-decl], :type :clj, :sym ns-tracker.parse} {:var-syms [*read-eval* *suppress-read* *default-data-reader-fn* read read-symbol default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* *wrap-value-and-add-metadata?* read-regex syntax-quote read-string map-func], :type :clj, :sym oakclojure.tools.reader} {:var-syms [default-uuid-reader validated oakclojure.tools.reader.default_data_readers.proxy$java.lang.ThreadLocal$ff19274a read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym oakclojure.tools.reader.default-data-readers} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern throwing-reader ratio-pattern], :type :clj, :sym oakclojure.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :clj, :sym oakclojure.tools.reader.impl.errors} {:var-syms [inspect inspect*], :type :clj, :sym oakclojure.tools.reader.impl.inspect} {:var-syms [whitespace? char numeric? make-var second' desugar-meta <=clojure-1-7-alpha5 ex-info? newline? namespace-keys compile-when], :type :clj, :sym oakclojure.tools.reader.impl.utils} {:var-syms [ReaderCoercer indexing-push-back-reader log-source* merge-meta ->StringReader to-pbr to-rdr Reader source-logging-push-back-reader unread peek-char push-back-reader IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line ->PushbackReader PushbackReaderCoercer string-push-back-reader log-source ->SourceLoggingPushbackReader ->InputStreamReader line-start? input-stream-push-back-reader source-logging-reader? IndexingReader get-line-number input-stream-reader ->IndexingPushbackReader], :type :clj, :sym oakclojure.tools.reader.reader-types} {:var-syms [on-receive accept run-server send! send-websocket-handshake! on-close with-channel Channel close sec-websocket-accept websocket? open?], :type :clj, :sym org.httpkit.server} {:var-syms [wrap-basic-authentication authentication-failure basic-authentication-request], :type :clj, :sym ring.middleware.basic-authentication} {:var-syms [wrap-content-type content-type-response], :type :clj, :sym ring.middleware.content-type} {:var-syms [file-request wrap-file], :type :clj, :sym ring.middleware.file} {:var-syms [head-request wrap-head head-response], :type :clj, :sym ring.middleware.head} {:var-syms [keyword-params-request wrap-keyword-params], :type :clj, :sym ring.middleware.keyword-params} {:var-syms [wrap-params params-request assoc-form-params assoc-query-params], :type :clj, :sym ring.middleware.params} {:var-syms [wrap-reload], :type :clj, :sym ring.middleware.reload} {:var-syms [wrap-resource resource-request], :type :clj, :sym ring.middleware.resource} {:var-syms [percent-encode url-decode fix-string-replace-bug form-encode form-decode-str form-decode assoc-conj url-encode FormEncodeable form-encode* base64-decode percent-decode base64-encode], :type :clj, :sym ring.util.codec} {:var-syms [last-modified-date close! piped-input-stream string-input-stream], :type :clj, :sym ring.util.io} {:var-syms [ext-mime-type default-mime-types], :type :clj, :sym ring.util.mime-type} {:var-syms [re-token re-quoted re-charset re-value], :type :clj, :sym ring.util.parsing} {:var-syms [request-url body-string content-length content-type path-info character-encoding urlencoded-form? set-context in-context?], :type :clj, :sym ring.util.request} {:var-syms [get-header redirect redirect-status-codes set-cookie response find-header file-response resource-response get-charset created header charset url-response redirect-after-post update-header resource-data status not-found content-type response?], :type :clj, :sym ring.util.response} {:var-syms [http-date-formats format-date parse-date], :type :clj, :sym ring.util.time} {:var-syms [mount unmount local reactive ref-node react render-static-markup request-render with-key build-defcs ref defc static defcs cursor state cursor-in dom-node with-ref build-defc render-html build-defcc derived-atom defcc], :type :clj, :sym rum.core} {:var-syms [->Cursor], :type :clj, :sym rum.cursor} {:var-syms [derived-atom], :type :clj, :sym rum.derived-atom} {:var-syms [normalize-css-value render-class! render-inner-html! *select-value* render-attrs! render-style-kv! normalize-css-key unitless-css-props render-static-markup to-str normalize-attr-key render-textarea-value! render-content! nothing? normalize-element render-attr! render-classes! append! get-value ToString parse-selector -render-html render-html HtmlRenderer render-element! normalized-attrs escape-html render-style! adler32], :type :clj, :sym rum.server-render} {:var-syms [call-all filter-vals collect collect*], :type :clj, :sym rum.util} {:var-syms [compile-merge-attrs compile-react compile-react-element to-js compile-attr ICompile compile-attrs compile-html IJSValue], :type :clj, :sym sablono.compiler} {:var-syms [map-lookup? attributes compact-map children element match-tag strip-css class class-name merge-with-class], :type :clj, :sym sablono.normalize} {:var-syms [join-classes to-str react-fn camel-case-keys element? *base-url* as-str html-to-dom-attrs ToString ToURI camel-case to-uri], :type :clj, :sym sablono.util} {:var-syms [special-indent code->tags indent-for-line adjust-indent read-safe unwrap-value get-tags-before-line forward-indent-for-line tag-map back-indent-for-line], :type :clj, :sym tag-soup.core}], :cljs-nses-and-vars {cljs.core ({:sym sort-by, :meta {:doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists [[keyfn coll] [keyfn comp coll]]}, :source "(defn\n sort-by\n \"Returns a sorted sequence of the items in coll, where the sort\\n   order is determined by comparing (keyfn item).  Comp can be\\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"\n ([keyfn coll] (sort-by keyfn compare coll))\n ([keyfn comp coll]\n  (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))\n"} {:sym ITransientAssociative, :meta {:doc "Protocol for adding associativity to transient collections."}, :methods (-assoc!)} {:sym chunk-first, :meta {:doc nil, :arglists ([s])}, :source "(defn chunk-first [s] (-chunked-first s))\n"} {:sym m3-hash-int, :meta {:doc nil, :arglists ([in])}, :source "(defn\n m3-hash-int\n [in]\n (if\n  (zero? in)\n  in\n  (let [k1 (m3-mix-K1 in) h1 (m3-mix-H1 m3-seed k1)] (m3-fmix h1 4))))\n"} {:sym pr-str*, :meta {:doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :arglists ([obj])}, :source "(defn\n pr-str*\n \"Support so that collections can implement toString without\\n   loading all the printing machinery.\"\n [obj]\n (let\n  [sb (StringBuffer.) writer (StringBufferWriter. sb)]\n  (-pr-writer obj writer (pr-opts))\n  (-flush writer)\n  (str sb)))\n"} {:sym tree-seq, :meta {:doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree.", :arglists ([branch? children root])}, :source "(defn\n tree-seq\n \"Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\\n  branch? must be a fn of one arg that returns true if passed a node\\n  that can have children (but may not).  children must be a fn of one\\n  arg that returns a sequence of the children. Will only be called on\\n  nodes for which branch? returns true. Root is the root node of the\\n  tree.\"\n [branch? children root]\n (let\n  [walk\n   (fn\n    walk\n    [node]\n    (lazy-seq\n     (cons node (when (branch? node) (mapcat walk (children node))))))]\n  (walk root)))\n"} {:sym unchecked-remainder-int, :meta {:doc nil, :arglists ([x n])}, :source "(defn\n unchecked-remainder-int\n [x n]\n (cljs.core/unchecked-remainder-int x n))\n"} {:sym seq, :meta {:doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :arglists ([coll])}, :source "(defn\n seq\n \"Returns a seq on the collection. If the collection is\\n  empty, returns nil.  (seq nil) returns nil. seq also works on\\n  Strings.\"\n [coll]\n (when-not\n  (nil? coll)\n  (cond\n   (implements? ISeqable coll)\n   (-seq coll)\n   (array? coll)\n   (when-not (zero? (alength coll)) (IndexedSeq. coll 0 nil))\n   (string? coll)\n   (when-not (zero? (alength coll)) (IndexedSeq. coll 0 nil))\n   (native-satisfies? ISeqable coll)\n   (-seq coll)\n   :else\n   (throw (js/Error. (str coll \" is not ISeqable\"))))))\n"} {:sym reduce, :meta {:doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :arglists [[f coll] [f val coll]]}, :source "(defn\n reduce\n \"f should be a function of 2 arguments. If val is not supplied,\\n  returns the result of applying f to the first 2 items in coll, then\\n  applying f to that result and the 3rd item, etc. If coll contains no\\n  items, f must accept no arguments as well, and reduce returns the\\n  result of calling f with no arguments.  If coll has only 1 item, it\\n  is returned and f is not called.  If val is supplied, returns the\\n  result of applying f to val and the first item in coll, then\\n  applying f to that result and the 2nd item, etc. If coll contains no\\n  items, returns val and f is not called.\"\n ([f coll]\n  (cond\n   (implements? IReduce coll)\n   (-reduce coll f)\n   (array? coll)\n   (array-reduce coll f)\n   (string? coll)\n   (array-reduce coll f)\n   (native-satisfies? IReduce coll)\n   (-reduce coll f)\n   (iterable? coll)\n   (iter-reduce coll f)\n   :else\n   (seq-reduce f coll)))\n ([f val coll]\n  (cond\n   (implements? IReduce coll)\n   (-reduce coll f val)\n   (array? coll)\n   (array-reduce coll f val)\n   (string? coll)\n   (array-reduce coll f val)\n   (native-satisfies? IReduce coll)\n   (-reduce coll f val)\n   (iterable? coll)\n   (iter-reduce coll f val)\n   :else\n   (seq-reduce f val coll))))\n"} {:sym contains?, :meta {:doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :arglists ([coll v])}, :source "(defn\n contains?\n \"Returns true if key is present in the given collection, otherwise\\n  returns false.  Note that for numerically indexed collections like\\n  vectors and arrays, this tests if the numeric key is within the\\n  range of indexes. 'contains?' operates constant or logarithmic time;\\n  it will not perform a linear search for a value.  See also 'some'.\"\n [coll v]\n (if\n  (identical? (get coll v lookup-sentinel) lookup-sentinel)\n  false\n  true))\n"} {:sym every?, :meta {:doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :arglists ([pred coll])}, :source "(defn\n every?\n \"Returns true if (pred x) is logical true for every x in coll, else\\n  false.\"\n [pred coll]\n (cond\n  (nil? (seq coll))\n  true\n  (pred (first coll))\n  (recur pred (next coll))\n  :else\n  false))\n"} {:sym keep-indexed, :meta {:doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :arglists [[f] [f coll]]}, :source "(defn\n keep-indexed\n \"Returns a lazy sequence of the non-nil results of (f index item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a stateful transducer when no collection is\\n  provided.\"\n ([f]\n  (fn\n   [rf]\n   (let\n    [ia (volatile! -1)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [i (vswap! ia inc) v (f i input)]\n       (if (nil? v) result (rf result v))))))))\n ([f coll]\n  (letfn\n   [(keepi\n     [idx coll]\n     (lazy-seq\n      (when-let\n       [s (seq coll)]\n       (if\n        (chunked-seq? s)\n        (let\n         [c (chunk-first s) size (count c) b (chunk-buffer size)]\n         (dotimes\n          [i size]\n          (let\n           [x (f (+ idx i) (-nth c i))]\n           (when-not (nil? x) (chunk-append b x))))\n         (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n        (let\n         [x (f idx (first s))]\n         (if\n          (nil? x)\n          (keepi (inc idx) (rest s))\n          (cons x (keepi (inc idx) (rest s)))))))))]\n   (keepi 0 coll))))\n"} {:sym subs, :meta {:doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :arglists [[s start] [s start end]]}, :source "(defn\n subs\n \"Returns the substring of s beginning at start inclusive, and ending\\n  at end (defaults to length of string), exclusive.\"\n ([s start] (.substring s start))\n ([s start end] (.substring s start end)))\n"} {:sym IFind, :meta {:doc "Protocol for implementing entry finding in collections."}, :methods (-find)} {:sym MODULE_URIS, :meta {}, :source "(def MODULE_URIS nil)\n"} {:sym take-last, :meta {:doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :arglists ([n coll])}, :source "(defn\n take-last\n \"Returns a seq of the last n items in coll.  Depending on the type\\n  of coll may be no better than linear time.  For vectors, see also subvec.\"\n [n coll]\n (loop\n  [s (seq coll) lead (seq (drop n coll))]\n  (if lead (recur (next s) (next lead)) s)))\n"} {:sym bit-set, :meta {:doc "Set bit at index n", :arglists ([x n])}, :source "(defn bit-set \"Set bit at index n\" [x n] (cljs.core/bit-set x n))\n"} {:sym string-hash-cache-count, :meta {}, :source "(def string-hash-cache-count 0)\n"} {:sym qualified-keyword?, :meta {:doc "Return true if x is a keyword with a namespace", :arglists ([x])}, :source "(defn\n qualified-keyword?\n \"Return true if x is a keyword with a namespace\"\n [x]\n (boolean (and (keyword? x) (namespace x) true)))\n"} {:sym -with-meta, :meta {:doc "Returns a new object with value of o and metadata meta added to it.", :arglists ([o meta])}, :protocol IWithMeta} {:sym unchecked-subtract-int, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-subtract-int\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/unchecked-subtract-int x))\n ([x y] (cljs.core/unchecked-subtract-int x y))\n ([x y & more]\n  (reduce\n   unchecked-subtract-int\n   (cljs.core/unchecked-subtract-int x y)\n   more)))\n"} {:sym -iterator, :meta {:doc "Returns an iterator for coll.", :arglists ([coll])}, :protocol IIterable} {:sym *print-namespace-maps*, :meta {:doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true."}, :source "(def *print-namespace-maps* false)\n"} {:sym first, :meta {:doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :arglists ([coll])}, :source "(defn\n first\n \"Returns the first item in the collection. Calls seq on its\\n  argument. If coll is nil, returns nil.\"\n [coll]\n (when-not\n  (nil? coll)\n  (if\n   (implements? ISeq coll)\n   (-first coll)\n   (let [s (seq coll)] (when-not (nil? s) (-first s))))))\n"} {:sym native-satisfies?, :meta {:doc "Internal - do not use!", :arglists ([p x])}, :source "(defn\n native-satisfies?\n \"Internal - do not use!\"\n [p x]\n (let\n  [x (if (nil? x) nil x)]\n  (cond\n   (unchecked-get p (goog/typeOf x))\n   true\n   (unchecked-get p \"_\")\n   true\n   :else\n   false)))\n"} {:sym seq?, :meta {:doc "Return true if s satisfies ISeq", :arglists ([s])}, :source "(defn\n seq?\n \"Return true if s satisfies ISeq\"\n [s]\n (if (nil? s) false (satisfies? ISeq s)))\n"} {:sym -sorted-seq-from, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :arglists ([coll k ascending?])}, :protocol ISorted} {:sym inst-ms, :meta {:doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", :arglists ([inst])}, :source "(defn\n inst-ms\n \"Return the number of milliseconds since January 1, 1970, 00:00:00 GMT\"\n [inst]\n (inst-ms* inst))\n"} {:sym iterate, :meta {:doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :arglists ([f x])}, :source "(defn\n iterate\n \"Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects\"\n {:added \"1.0\"}\n [f x]\n (cons x (lazy-seq (iterate f (f x)))))\n"} {:sym -empty, :meta {:doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.", :arglists ([coll])}, :protocol IEmptyableCollection} {:sym ILookup, :meta {:doc "Protocol for looking up a value in a data structure."}, :methods (-lookup)} {:sym -chunked-rest, :meta {:doc "Return a new collection of coll with the first chunk removed.", :arglists ([coll])}, :protocol IChunkedSeq} {:sym fn?, :meta {:doc "Return true if f is a JavaScript function or satisfies the Fn protocol.", :arglists ([f])}, :source "(defn\n fn?\n \"Return true if f is a JavaScript function or satisfies the Fn protocol.\"\n [f]\n (or (goog/isFunction f) (satisfies? Fn f)))\n"} {:sym -assoc, :meta {:doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :arglists ([coll k v])}, :protocol IAssociative} {:sym keyword-identical?, :meta {:doc "Efficient test to determine that two keywords are identical.", :arglists ([x y])}, :source "(defn\n keyword-identical?\n \"Efficient test to determine that two keywords are identical.\"\n [x y]\n (if\n  (identical? x y)\n  true\n  (if\n   (and (keyword? x) (keyword? y))\n   (identical? (.-fqn x) (.-fqn y))\n   false)))\n"} {:sym *print-err-fn*, :meta {:doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed."}, :source "(defonce *print-err-fn* nil)\n"} {:sym dissoc, :meta {:doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :arglists [[coll] [coll k] [coll k & ks]]}, :source "(defn\n dissoc\n \"dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\\n  that does not contain a mapping for key(s).\"\n ([coll] coll)\n ([coll k] (when-not (nil? coll) (-dissoc coll k)))\n ([coll k & ks]\n  (when-not\n   (nil? coll)\n   (let\n    [ret (dissoc coll k)]\n    (if ks (recur ret (first ks) (next ks)) ret)))))\n"} {:sym atom, :meta {:doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will be come the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.", :arglists [[x] [x & {:keys [meta validator]}]]}, :source "(defn\n atom\n \"Creates and returns an Atom with an initial value of x and zero or\\n  more options (in any order):\\n\\n  :meta metadata-map\\n\\n  :validator validate-fn\\n\\n  If metadata-map is supplied, it will be come the metadata on the\\n  atom. validate-fn must be nil or a side-effect-free fn of one\\n  argument, which will be passed the intended new state on any state\\n  change. If the new state is unacceptable, the validate-fn should\\n  return false or throw an Error.  If either of these error conditions\\n  occur, then the value of the atom will not change.\"\n ([x] (Atom. x nil nil nil))\n ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))\n"} {:sym bit-shift-right, :meta {:doc "Bitwise shift right", :arglists ([x n])}, :source "(defn\n bit-shift-right\n \"Bitwise shift right\"\n [x n]\n (cljs.core/bit-shift-right x n))\n"} {:sym *clojurescript-version*, :meta {}, :source "(def *clojurescript-version* \"1.9.946\")\n"} {:sym -first, :meta {:doc "Returns the first item in the collection coll. Used by cljs.core/first.", :arglists ([coll])}, :protocol ISeq} {:sym peek, :meta {:doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :arglists ([coll])}, :source "(defn\n peek\n \"For a list or queue, same as first, for a vector, same as, but much\\n  more efficient than, last. If the collection is empty, returns nil.\"\n [coll]\n (when-not (nil? coll) (-peek coll)))\n"} {:sym IKVReduce, :meta {:doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv."}, :methods (-kv-reduce)} {:sym aget, :meta {:doc "Returns the value at the index/indices. Works on JavaScript arrays.", :arglists [[array idx] [array idx & idxs]]}, :source "(defn\n aget\n \"Returns the value at the index/indices. Works on JavaScript arrays.\"\n ([array idx] (cljs.core/aget array idx))\n ([array idx & idxs] (apply aget (aget array idx) idxs)))\n"} {:sym -write, :meta {:doc "Writes s with writer and returns the result.", :arglists ([writer s])}, :protocol IWriter} {:sym iter, :meta {:doc nil, :arglists ([coll])}, :source "(defn\n iter\n [coll]\n (cond\n  (iterable? coll)\n  (-iterator coll)\n  (nil? coll)\n  (nil-iter)\n  (string? coll)\n  (string-iter coll)\n  (array? coll)\n  (array-iter coll)\n  (seqable? coll)\n  (seq-iter coll)\n  :else\n  (throw (js/Error. (str \"Cannot create iterator from \" coll)))))\n"} {:sym last, :meta {:doc "Return the last item in coll, in linear time", :arglists ([s])}, :source "(defn\n last\n \"Return the last item in coll, in linear time\"\n [s]\n (let [sn (next s)] (if-not (nil? sn) (recur sn) (first s))))\n"} {:sym namespace, :meta {:doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :arglists ([x])}, :source "(defn\n namespace\n \"Returns the namespace String of a symbol or keyword, or nil if not present.\"\n [x]\n (if\n  (implements? INamed x)\n  (-namespace x)\n  (throw (js/Error. (str \"Doesn't support namespace: \" x)))))\n"} {:sym -conj, :meta {:doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :arglists ([coll o])}, :protocol ICollection} {:sym =, :meta {:doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n =\n \"Equality. Returns true if x equals y, false if not. Compares\\n  numbers and collections in a type-independent manner.  Clojure's immutable data\\n  structures define -equiv (and thus =) as a value, not an identity,\\n  comparison.\"\n ([x] true)\n ([x y] (if (nil? x) (nil? y) (or (identical? x y) (-equiv x y))))\n ([x y & more]\n  (if\n   (= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (= y (first more)))\n   false)))\n"} {:sym ITransientMap, :meta {:doc "Protocol for adding mapping functionality to transient collections."}, :methods (-dissoc!)} {:sym take, :meta {:doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :arglists [[n] [n coll]]}, :source "(defn\n take\n \"Returns a lazy sequence of the first n items in coll, or all items if\\n  there are fewer than n.  Returns a stateful transducer when\\n  no collection is provided.\"\n ([n]\n  {:pre [(number? n)]}\n  (fn\n   [rf]\n   (let\n    [na (volatile! n)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [n\n        @na\n        nn\n        (vswap! na dec)\n        result\n        (if (pos? n) (rf result input) result)]\n       (if (not (pos? nn)) (ensure-reduced result) result)))))))\n ([n coll]\n  {:pre [(number? n)]}\n  (lazy-seq\n   (when\n    (pos? n)\n    (when-let\n     [s (seq coll)]\n     (cons (first s) (take (dec n) (rest s))))))))\n"} {:sym vector?, :meta {:doc "Return true if x satisfies IVector", :arglists ([x])}, :source "(defn\n vector?\n \"Return true if x satisfies IVector\"\n [x]\n (satisfies? IVector x))\n"} {:sym boolean, :meta {:doc "Coerce to boolean", :arglists ([x])}, :source "(defn\n boolean\n \"Coerce to boolean\"\n [x]\n (cond (nil? x) false (false? x) false :else true))\n"} {:sym IChunk, :meta {:doc "Protocol for accessing the items of a chunk."}, :methods (-drop-first)} {:sym bit-shift-left, :meta {:doc "Bitwise shift left", :arglists ([x n])}, :source "(defn\n bit-shift-left\n \"Bitwise shift left\"\n [x n]\n (cljs.core/bit-shift-left x n))\n"} {:sym any?, :meta {:doc "Returns true if given any argument.", :arglists ([x])}, :source "(defn any? \"Returns true if given any argument.\" [x] true)\n"} {:sym aclone, :meta {:doc "Returns a javascript array, cloned from the passed in array", :arglists ([arr])}, :source "(defn\n aclone\n \"Returns a javascript array, cloned from the passed in array\"\n [arr]\n (let\n  [len (alength arr) new-arr (make-array len)]\n  (dotimes [i len] (aset new-arr i (aget arr i)))\n  new-arr))\n"} {:sym vreset!, :meta {:doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :arglists ([vol newval])}, :source "(defn\n vreset!\n \"Sets the value of volatile to newval without regard for the\\n   current value. Returns newval.\"\n [vol newval]\n (-vreset! vol newval))\n"} {:sym chunk, :meta {:doc nil, :arglists ([b])}, :source "(defn chunk [b] (.chunk b))\n"} {:sym dec, :meta {:doc "Returns a number one less than num.", :arglists ([x])}, :source "(defn dec \"Returns a number one less than num.\" [x] (- x 1))\n"} {:sym APersistentVector, :meta {:doc "Marker protocol"}, :methods ()} {:sym map, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :arglists [[f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]]}, :source "(defn\n map\n \"Returns a lazy sequence consisting of the result of applying f to\\n  the set of first items of each coll, followed by applying f to the\\n  set of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments. Returns a transducer when\\n  no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input] (rf result (f input)))\n    ([result input & inputs] (rf result (apply f input inputs))))))\n ([f coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes [i size] (chunk-append b (f (-nth c i))))\n      (chunk-cons (chunk b) (map f (chunk-rest s))))\n     (cons (f (first s)) (map f (rest s)))))))\n ([f c1 c2]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2)]\n    (when\n     (and s1 s2)\n     (cons (f (first s1) (first s2)) (map f (rest s1) (rest s2)))))))\n ([f c1 c2 c3]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n    (when\n     (and s1 s2 s3)\n     (cons\n      (f (first s1) (first s2) (first s3))\n      (map f (rest s1) (rest s2) (rest s3)))))))\n ([f c1 c2 c3 & colls]\n  (let\n   [step\n    (fn\n     step\n     [cs]\n     (lazy-seq\n      (let\n       [ss (map seq cs)]\n       (when\n        (every? identity ss)\n        (cons (map first ss) (step (map rest ss)))))))]\n   (map\n    (fn* [p1__19424#] (apply f p1__19424#))\n    (step (conj colls c3 c2 c1))))))\n"} {:sym <, :meta {:doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n <\n \"Returns non-nil if nums are in monotonically increasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/< x y))\n ([x y & more]\n  (if\n   (cljs.core/< x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/< y (first more)))\n   false)))\n"} {:sym rest, :meta {:doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :arglists ([coll])}, :source "(defn\n rest\n \"Returns a possibly empty seq of the items after the first. Calls seq on its\\n  argument.\"\n [coll]\n (if-not\n  (nil? coll)\n  (if\n   (implements? ISeq coll)\n   (-rest coll)\n   (let [s (seq coll)] (if s (-rest s) ())))\n  ()))\n"} {:sym -drop-first, :meta {:doc "Return a new chunk of coll with the first item removed.", :arglists ([coll])}, :protocol IChunk} {:sym boolean?, :meta {:doc "Return true if x is a Boolean", :arglists ([x])}, :source "(defn\n boolean?\n \"Return true if x is a Boolean\"\n [x]\n (or (cljs.core/true? x) (cljs.core/false? x)))\n"} {:sym -clone, :meta {:doc "Creates a clone of value.", :arglists ([value])}, :protocol ICloneable} {:sym char?, :meta {:doc "Returns true if x is a JavaScript string of length one.", :arglists ([x])}, :source "(defn\n char?\n \"Returns true if x is a JavaScript string of length one.\"\n [x]\n (and (string? x) (== 1 (.-length x))))\n"} {:sym -reduce, :meta {:doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :arglists ([coll f] [coll f start])}, :protocol IReduce} {:sym -count, :meta {:doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :arglists ([coll])}, :protocol ICounted} {:sym swap-vals!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", :arglists [[a f] [a f x] [a f x y] [a f x y & more]]}, :source "(defn\n swap-vals!\n \"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.\\n  Returns [old new], the value of the atom before and after the swap.\"\n {:added \"1.9\"}\n ([a f] (reset-vals! a (f (.-state a))))\n ([a f x] (reset-vals! a (f (.-state a) x)))\n ([a f x y] (reset-vals! a (f (.-state a) x y)))\n ([a f x y & more] (reset-vals! a (apply f (.-state a) x y more))))\n"} {:sym keep, :meta {:doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :arglists [[f] [f coll]]}, :source "(defn\n keep\n \"Returns a lazy sequence of the non-nil results of (f item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a transducer when no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input]\n     (let [v (f input)] (if (nil? v) result (rf result v)))))))\n ([f coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes\n       [i size]\n       (let [x (f (-nth c i))] (when-not (nil? x) (chunk-append b x))))\n      (chunk-cons (chunk b) (keep f (chunk-rest s))))\n     (let\n      [x (f (first s))]\n      (if (nil? x) (keep f (rest s)) (cons x (keep f (rest s))))))))))\n"} {:sym char, :meta {:doc "Coerce to char", :arglists ([x])}, :source "(defn\n char\n \"Coerce to char\"\n [x]\n (cond\n  (number? x)\n  (.fromCharCode js/String x)\n  (and (string? x) (== (.-length x) 1))\n  x\n  :else\n  (throw (js/Error. \"Argument to char must be a character or number\"))))\n"} {:sym mapcat, :meta {:doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :arglists [[f] [f & colls]]}, :source "(defn\n mapcat\n \"Returns the result of applying concat to the result of applying map\\n  to f and colls.  Thus function f should return a collection. Returns\\n  a transducer when no collections are provided\"\n {:added \"1.0\", :static true}\n ([f] (comp (map f) cat))\n ([f & colls] (apply concat (apply map f colls))))\n"} {:sym unchecked-long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :source "(defn\n unchecked-long\n \"Coerce to long by stripping decimal places. Identical to `int'.\"\n [x]\n (fix x))\n"} {:sym m3-seed, :meta {}, :source "(def m3-seed 0)\n"} {:sym some?, :meta {:doc "Returns true if x is not nil, false otherwise.", :arglists ([x])}, :source "(defn\n some?\n \"Returns true if x is not nil, false otherwise.\"\n [x]\n (not (nil? x)))\n"} {:sym unchecked-negate, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-negate [x] (cljs.core/unchecked-negate x))\n"} {:sym symbol-identical?, :meta {:doc "Efficient test to determine that two symbols are identical.", :arglists ([x y])}, :source "(defn\n symbol-identical?\n \"Efficient test to determine that two symbols are identical.\"\n [x y]\n (if\n  (identical? x y)\n  true\n  (if\n   (and (symbol? x) (symbol? y))\n   (identical? (.-str x) (.-str y))\n   false)))\n"} {:sym *command-line-args*, :meta {:doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied"}, :source "(def *command-line-args* nil)\n"} {:sym reverse, :meta {:doc "Returns a seq of the items in coll in reverse order. Not lazy.", :arglists ([coll])}, :source "(defn\n reverse\n \"Returns a seq of the items in coll in reverse order. Not lazy.\"\n [coll]\n (if (reversible? coll) (rseq coll) (reduce conj () coll)))\n"} {:sym inst?, :meta {:doc "Return true if x satisfies Inst", :arglists ([x])}, :source "(defn inst? \"Return true if x satisfies Inst\" [x] (satisfies? Inst x))\n"} {:sym bit-count, :meta {:doc "Counts the number of bits set in n", :arglists ([v])}, :source "(defn\n bit-count\n \"Counts the number of bits set in n\"\n [v]\n (let\n  [v\n   (- v (bit-and (bit-shift-right v 1) 1431655765))\n   v\n   (+ (bit-and v 858993459) (bit-and (bit-shift-right v 2) 858993459))]\n  (bit-shift-right\n   (* (bit-and (+ v (bit-shift-right v 4)) 252645135) 16843009)\n   24)))\n"} {:sym sort, :meta {:doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists [[coll] [comp coll]]}, :source "(defn\n sort\n \"Returns a sorted sequence of the items in coll. Comp can be\\n   boolean-valued comparison function, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"\n ([coll] (sort compare coll))\n ([comp coll]\n  (if\n   (seq coll)\n   (let\n    [a (to-array coll)]\n    (garray/stableSort a (fn->comparator comp))\n    (seq a))\n   ())))\n"} {:sym unchecked-inc-int, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-inc-int [x] (cljs.core/unchecked-inc-int x))\n"} {:sym -compare, :meta {:doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :arglists ([x y])}, :protocol IComparable} {:sym map-indexed, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :arglists [[f] [f coll]]}, :source "(defn\n map-indexed\n \"Returns a lazy sequence consisting of the result of applying f to 0\\n  and the first item of coll, followed by applying f to 1 and the second\\n  item in coll, etc, until coll is exhausted. Thus function f should\\n  accept 2 arguments, index and item. Returns a stateful transducer when\\n  no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (let\n    [i (volatile! -1)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input] (rf result (f (vswap! i inc) input)))))))\n ([f coll]\n  (letfn\n   [(mapi\n     [idx coll]\n     (lazy-seq\n      (when-let\n       [s (seq coll)]\n       (if\n        (chunked-seq? s)\n        (let\n         [c (chunk-first s) size (count c) b (chunk-buffer size)]\n         (dotimes [i size] (chunk-append b (f (+ idx i) (-nth c i))))\n         (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n        (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n   (mapi 0 coll))))\n"} {:sym comp, :meta {:doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :arglists [[] [f] [f g] [f g h] [f1 f2 f3 & fs]]}, :source "(defn\n comp\n \"Takes a set of functions and returns a fn that is the composition\\n  of those fns.  The returned fn takes a variable number of args,\\n  applies the rightmost of fns to the args, the next\\n  fn (right-to-left) to the result, etc.\"\n ([] identity)\n ([f] f)\n ([f g]\n  (fn\n   ([] (f (g)))\n   ([x] (f (g x)))\n   ([x y] (f (g x y)))\n   ([x y z] (f (g x y z)))\n   ([x y z & args] (f (apply g x y z args)))))\n ([f g h]\n  (fn\n   ([] (f (g (h))))\n   ([x] (f (g (h x))))\n   ([x y] (f (g (h x y))))\n   ([x y z] (f (g (h x y z))))\n   ([x y z & args] (f (g (apply h x y z args))))))\n ([f1 f2 f3 & fs]\n  (let\n   [fs (reverse (list* f1 f2 f3 fs))]\n   (fn\n    [& args]\n    (loop\n     [ret (apply (first fs) args) fs (next fs)]\n     (if fs (recur ((first fs) ret) (next fs)) ret))))))\n"} {:sym array-chunk, :meta {:doc nil, :arglists [[arr] [arr off] [arr off end]]}, :source "(defn\n array-chunk\n ([arr] (ArrayChunk. arr 0 (alength arr)))\n ([arr off] (ArrayChunk. arr off (alength arr)))\n ([arr off end] (ArrayChunk. arr off end)))\n"} {:sym bit-shift-right-zero-fill, :meta {:doc "DEPRECATED: Bitwise shift right with zero fill", :arglists ([x n])}, :source "(defn\n bit-shift-right-zero-fill\n \"DEPRECATED: Bitwise shift right with zero fill\"\n [x n]\n (cljs.core/bit-shift-right-zero-fill x n))\n"} {:sym -as-transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :protocol IEditableCollection} {:sym simple-symbol?, :meta {:doc "Return true if x is a symbol without a namespace", :arglists ([x])}, :source "(defn\n simple-symbol?\n \"Return true if x is a symbol without a namespace\"\n [x]\n (and (symbol? x) (nil? (namespace x))))\n"} {:sym IIndexed, :meta {:doc "Protocol for collections to provide indexed-based access to their items."}, :methods (-nth)} {:sym disj, :meta {:doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists [[coll] [coll k] [coll k & ks]]}, :source "(defn\n disj\n \"disj[oin]. Returns a new set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"\n ([coll] coll)\n ([coll k] (when-not (nil? coll) (-disjoin coll k)))\n ([coll k & ks]\n  (when-not\n   (nil? coll)\n   (let\n    [ret (disj coll k)]\n    (if ks (recur ret (first ks) (next ks)) ret)))))\n"} {:sym IPrintWithWriter, :meta {:doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."}, :methods (-pr-writer)} {:sym IVector, :meta {:doc "Protocol for adding vector functionality to collections."}, :methods (-assoc-n)} {:sym IIterable, :meta {:doc "Protocol for iterating over a collection."}, :methods (-iterator)} {:sym cons, :meta {:doc "Returns a new seq where x is the first element and coll is the rest.", :arglists ([x coll])}, :source "(defn\n cons\n \"Returns a new seq where x is the first element and coll is the rest.\"\n [x coll]\n (if\n  (or (nil? coll) (implements? ISeq coll))\n  (Cons. nil x coll nil)\n  (Cons. nil x (seq coll) nil)))\n"} {:sym floats, :meta {:doc nil, :arglists ([x])}, :source "(defn floats [x] x)\n"} {:sym pos?, :meta {:doc "Returns true if num is greater than zero, else false", :arglists ([x])}, :source "(defn\n pos?\n \"Returns true if num is greater than zero, else false\"\n [x]\n (cljs.core/pos? x))\n"} {:sym fnil, :meta {:doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :arglists [[f x] [f x y] [f x y z]]}, :source "(defn\n fnil\n \"Takes a function f, and returns a function that calls f, replacing\\n  a nil first argument to f with the supplied value x. Higher arity\\n  versions can replace arguments in the second and third\\n  positions (y, z). Note that the function f can take any number of\\n  arguments, not just the one(s) being nil-patched.\"\n ([f x]\n  (fn\n   ([a] (f (if (nil? a) x a)))\n   ([a b] (f (if (nil? a) x a) b))\n   ([a b c] (f (if (nil? a) x a) b c))\n   ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n ([f x y]\n  (fn\n   ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n   ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n   ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n ([f x y z]\n  (fn\n   ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n   ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n   ([a b c & ds]\n    (apply\n     f\n     (if (nil? a) x a)\n     (if (nil? b) y b)\n     (if (nil? c) z c)\n     ds)))))\n"} {:sym nthrest, :meta {:doc "Returns the nth rest of coll, coll when n is 0.", :arglists ([coll n])}, :source "(defn\n nthrest\n \"Returns the nth rest of coll, coll when n is 0.\"\n [coll n]\n (loop\n  [n n xs coll]\n  (if (and (pos? n) (seq xs)) (recur (dec n) (rest xs)) xs)))\n"} {:sym *warn-on-infer*, :meta {}, :source "(def *warn-on-infer* false)\n"} {:sym -find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :protocol IFind} {:sym sequential?, :meta {:doc "Returns true if coll satisfies ISequential", :arglists ([x])}, :source "(defn\n sequential?\n \"Returns true if coll satisfies ISequential\"\n [x]\n (satisfies? ISequential x))\n"} {:sym m3-mix-H1, :meta {:doc nil, :arglists ([h1 k1])}, :source "(defn\n m3-mix-H1\n [h1 k1]\n (int\n  (->\n   (int h1)\n   (bit-xor (int k1))\n   (int-rotate-left 13)\n   (imul 5)\n   (+ (int 3864292196)))))\n"} {:sym prim-seq, :meta {:doc "Create seq from a primitive JavaScript Array-like.", :arglists [[prim] [prim i]]}, :source "(defn\n prim-seq\n \"Create seq from a primitive JavaScript Array-like.\"\n ([prim] (prim-seq prim 0))\n ([prim i] (when (< i (alength prim)) (IndexedSeq. prim i nil))))\n"} {:sym *print-level*, :meta {:doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit."}, :source "(def *print-level* nil)\n"} {:sym shuffle, :meta {:doc "Return a random permutation of coll", :arglists ([coll])}, :source "(defn\n shuffle\n \"Return a random permutation of coll\"\n [coll]\n (let [a (to-array coll)] (garray/shuffle a) (vec a)))\n"} {:sym hash-keyword, :meta {:doc nil, :arglists ([k])}, :source "(defn hash-keyword [k] (int (+ (hash-symbol k) 2654435769)))\n"} {:sym find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :source "(defn\n find\n \"Returns the map entry for key, or nil if key not present.\"\n [coll k]\n (if\n  (ifind? coll)\n  (-find coll k)\n  (when\n   (and (not (nil? coll)) (associative? coll) (contains? coll k))\n   [k (get coll k)])))\n"} {:sym alength, :meta {:doc "Returns the length of the array. Works on arrays of all types.", :arglists ([array])}, :source "(defn\n alength\n \"Returns the length of the array. Works on arrays of all types.\"\n [array]\n (cljs.core/alength array))\n"} {:sym bit-xor, :meta {:doc "Bitwise exclusive or", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-xor\n \"Bitwise exclusive or\"\n ([x y] (cljs.core/bit-xor x y))\n ([x y & more] (reduce bit-xor (cljs.core/bit-xor x y) more)))\n"} {:sym unsigned-bit-shift-right, :meta {:doc "Bitwise shift right with zero fill", :arglists ([x n])}, :source "(defn\n unsigned-bit-shift-right\n \"Bitwise shift right with zero fill\"\n [x n]\n (cljs.core/unsigned-bit-shift-right x n))\n"} {:sym neg?, :meta {:doc "Returns true if num is less than zero, else false", :arglists ([x])}, :source "(defn\n neg?\n \"Returns true if num is less than zero, else false\"\n [x]\n (cljs.core/neg? x))\n"} {:sym js-invoke, :meta {:doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :arglists ([obj s & args])}, :source "(defn\n js-invoke\n \"Invoke JavaScript object method via string. Needed when the\\n  string is not a valid unquoted property name.\"\n [obj s & args]\n (.apply (unchecked-get obj s) obj (into-array args)))\n"} {:sym m3-mix-K1, :meta {:doc nil, :arglists ([k1])}, :source "(defn\n m3-mix-K1\n [k1]\n (-> (int k1) (imul m3-C1) (int-rotate-left 15) (imul m3-C2)))\n"} {:sym unchecked-float, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-float [x] x)\n"} {:sym undefined?, :meta {:doc "Returns true if x identical to the JavaScript undefined value.", :arglists ([x])}, :source "(defn\n undefined?\n \"Returns true if x identical to the JavaScript undefined value.\"\n [x]\n (cljs.core/undefined? x))\n"} {:sym IMeta, :meta {:doc "Protocol for accessing the metadata of an object."}, :methods (-meta)} {:sym reduced?, :meta {:doc "Returns true if x is the result of a call to reduced", :arglists ([r])}, :source "(defn\n reduced?\n \"Returns true if x is the result of a call to reduced\"\n [r]\n (instance? Reduced r))\n"} {:sym disj!, :meta {:doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists [[tcoll val] [tcoll val & vals]]}, :source "(defn\n disj!\n \"disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"\n ([tcoll val] (-disjoin! tcoll val))\n ([tcoll val & vals]\n  (let\n   [ntcoll (-disjoin! tcoll val)]\n   (if vals (recur ntcoll (first vals) (next vals)) ntcoll))))\n"} {:sym -lookup, :meta {:doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :arglists ([o k] [o k not-found])}, :protocol ILookup} {:sym float?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :source "(defn\n float?\n \"Returns true for JavaScript numbers, false otherwise.\"\n [x]\n (number? x))\n"} {:sym ICloneable, :meta {:doc "Protocol for cloning a value."}, :methods (-clone)} {:sym booleans, :meta {:doc nil, :arglists ([x])}, :source "(defn booleans [x] x)\n"} {:sym int-array, :meta {:doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n int-array\n \"Creates an array of ints. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (int-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym set?, :meta {:doc "Returns true if x satisfies ISet", :arglists ([x])}, :source "(defn\n set?\n \"Returns true if x satisfies ISet\"\n [x]\n (if (nil? x) false (satisfies? ISet x)))\n"} {:sym iterable?, :meta {:doc "Return true if x implements IIterable protocol.", :arglists ([x])}, :source "(defn\n iterable?\n \"Return true if x implements IIterable protocol.\"\n [x]\n (satisfies? IIterable x))\n"} {:sym -pr-writer, :meta {:doc nil, :arglists ([o writer opts])}, :protocol IPrintWithWriter} {:sym vary-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :arglists [[obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]]}, :source "(defn\n vary-meta\n \"Returns an object of the same type and value as obj, with\\n  (apply f (meta obj) args) as its metadata.\"\n ([obj f] (with-meta obj (f (meta obj))))\n ([obj f a] (with-meta obj (f (meta obj) a)))\n ([obj f a b] (with-meta obj (f (meta obj) a b)))\n ([obj f a b c] (with-meta obj (f (meta obj) a b c)))\n ([obj f a b c d] (with-meta obj (f (meta obj) a b c d)))\n ([obj f a b c d & args]\n  (with-meta obj (apply f (meta obj) a b c d args))))\n"} {:sym INext, :meta {:doc "Protocol for accessing the next items of a collection."}, :methods (-next)} {:sym is_proto_, :meta {:doc nil, :arglists ([x])}, :source "(defn is_proto_ [x] (identical? (.-prototype (.-constructor x)) x))\n"} {:sym ICounted, :meta {:doc "Protocol for adding the ability to count a collection in constant time."}, :methods (-count)} {:sym IMapEntry, :meta {:doc "Protocol for examining a map entry."}, :methods (-key -val)} {:sym <=, :meta {:doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n <=\n \"Returns non-nil if nums are in monotonically non-decreasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/<= x y))\n ([x y & more]\n  (if\n   (cljs.core/<= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/<= y (first more)))\n   false)))\n"} {:sym MODULE_INFOS, :meta {}, :source "(def MODULE_INFOS nil)\n"} {:sym conj!, :meta {:doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :arglists [[] [tcoll] [tcoll val] [tcoll val & vals]]}, :source "(defn\n conj!\n \"Adds val to the transient collection, and return tcoll. The 'addition'\\n  may happen at different 'places' depending on the concrete type.\"\n ([] (transient []))\n ([tcoll] tcoll)\n ([tcoll val] (-conj! tcoll val))\n ([tcoll val & vals]\n  (let\n   [ntcoll (-conj! tcoll val)]\n   (if vals (recur ntcoll (first vals) (next vals)) ntcoll))))\n"} {:sym -pop, :meta {:doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :arglists ([coll])}, :protocol IStack} {:sym repeatedly, :meta {:doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :arglists [[f] [n f]]}, :source "(defn\n repeatedly\n \"Takes a function of no args, presumably with side effects, and\\n  returns an infinite (or length n if supplied) lazy sequence of calls\\n  to it\"\n ([f] (lazy-seq (cons (f) (repeatedly f))))\n ([n f] (take n (repeatedly f))))\n"} {:sym reset-vals!, :meta {:doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", :arglists ([a new-value])}, :source "(defn\n reset-vals!\n \"Sets the value of atom to newval. Returns [old new], the value of the\\n   atom before and after the reset.\"\n {:added \"1.9\"}\n [a new-value]\n (let\n  [validate (.-validator a)]\n  (when-not\n   (nil? validate)\n   (when-not\n    (validate new-value)\n    (throw (js/Error. \"Validator rejected reference state\"))))\n  (let\n   [old-value (.-state a)]\n   (set! (.-state a) new-value)\n   (when-not\n    (nil? (.-watches a))\n    (-notify-watches a old-value new-value))\n   [old-value new-value])))\n"} {:sym IStack, :meta {:doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures."}, :methods (-peek -pop)} {:sym -remove-watch, :meta {:doc "Removes watcher that corresponds to key from this.", :arglists ([this key])}, :protocol IWatchable} {:sym IVolatile, :meta {:doc "Protocol for adding volatile functionality."}, :methods (-vreset!)} {:sym remove, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n remove\n \"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns false. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"\n ([pred] (filter (complement pred)))\n ([pred coll] (filter (complement pred) coll)))\n"} {:sym *, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n *\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/* x y))\n ([x y & more] (reduce * (cljs.core/* x y) more)))\n"} {:sym min, :meta {:doc "Returns the least of the nums.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n min\n \"Returns the least of the nums.\"\n ([x] x)\n ([x y] (cljs.core/min x y))\n ([x y & more] (reduce min (cljs.core/min x y) more)))\n"} {:sym -persistent!, :meta {:doc "Creates a persistent data structure from tcoll and returns it.", :arglists ([tcoll])}, :protocol ITransientCollection} {:sym -nth, :meta {:doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :arglists ([coll n] [coll n not-found])}, :protocol IIndexed} {:sym pop!, :meta {:doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll", :arglists ([tcoll])}, :source "(defn\n pop!\n \"Removes the last item from a transient vector. If\\n  the collection is empty, throws an exception. Returns tcoll\"\n [tcoll]\n (-pop! tcoll))\n"} {:sym chunk-append, :meta {:doc nil, :arglists ([b x])}, :source "(defn chunk-append [b x] (.add b x))\n"} {:sym *unchecked-arrays*, :meta {}, :source "(def *unchecked-arrays* false)\n"} {:sym IReversible, :meta {:doc "Protocol for reversing a seq."}, :methods (-rseq)} {:sym reversible?, :meta {:doc "Returns true if coll satisfies? IReversible.", :arglists ([coll])}, :source "(defn\n reversible?\n \"Returns true if coll satisfies? IReversible.\"\n [coll]\n (satisfies? IReversible coll))\n"} {:sym -realized?, :meta {:doc "Returns true if a value for x has been produced, false otherwise.", :arglists ([x])}, :protocol IPending} {:sym -add-watch, :meta {:doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :arglists ([this key f])}, :protocol IWatchable} {:sym -deref-with-timeout, :meta {:doc nil, :arglists ([o msec timeout-val])}, :protocol IDerefWithTimeout} {:sym conj, :meta {:doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :arglists [[] [coll] [coll x] [coll x & xs]]}, :source "(defn\n conj\n \"conj[oin]. Returns a new collection with the xs\\n  'added'. (conj nil item) returns (item).  The 'addition' may\\n  happen at different 'places' depending on the concrete type.\"\n ([] [])\n ([coll] coll)\n ([coll x] (if-not (nil? coll) (-conj coll x) (list x)))\n ([coll x & xs]\n  (if xs (recur (conj coll x) (first xs) (next xs)) (conj coll x))))\n"} {:sym -sorted-seq, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.", :arglists ([coll ascending?])}, :protocol ISorted} {:sym transduce, :meta {:doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :arglists [[xform f coll] [xform f init coll]]}, :source "(defn\n transduce\n \"reduce with a transformation of f (xf). If init is not\\n  supplied, (f) will be called to produce it. f should be a reducing\\n  step function that accepts both 1 and 2 arguments, if it accepts\\n  only 2 you can add the arity-1 with 'completing'. Returns the result\\n  of applying (the transformed) xf to init and the first item in coll,\\n  then applying xf to that result and the 2nd item, etc. If coll\\n  contains no items, returns init and f is not called. Note that\\n  certain transforms may inject or skip items.\"\n ([xform f coll] (transduce xform f (f) coll))\n ([xform f init coll]\n  (let [f (xform f) ret (reduce f init coll)] (f ret))))\n"} {:sym -swap!, :meta {:doc "Swaps the value of o to be (apply f current-value-of-atom args).", :arglists ([o f] [o f a] [o f a b] [o f a b xs])}, :protocol ISwap} {:sym *print-length*, :meta {:doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit."}, :source "(def *print-length* nil)\n"} {:sym js-delete, :meta {:doc "Delete a property from a JavaScript object.", :arglists ([obj key])}, :source "(defn\n js-delete\n \"Delete a property from a JavaScript object.\"\n [obj key]\n (cljs.core/js-delete obj key))\n"} {:sym truth_, :meta {:doc "Internal - do not use!", :arglists ([x])}, :source "(defn truth_ \"Internal - do not use!\" [x] (cljs.core/truth_ x))\n"} {:sym compare-and-set!, :meta {:doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :arglists ([a oldval newval])}, :source "(defn\n compare-and-set!\n \"Atomically sets the value of atom to newval if and only if the\\n  current value of the atom is equal to oldval. Returns true if\\n  set happened, else false.\"\n [a oldval newval]\n (if (= (-deref a) oldval) (do (reset! a newval) true) false))\n"} {:sym array-seq, :meta {:doc "Create a seq from a JavaScript array.", :arglists [[array] [array i]]}, :source "(defn\n array-seq\n \"Create a seq from a JavaScript array.\"\n ([array] (prim-seq array 0))\n ([array i] (prim-seq array i)))\n"} {:sym interleave, :meta {:doc "Returns a lazy seq of the first item in each coll, then the second etc.", :arglists [[] [c1] [c1 c2] [c1 c2 & colls]]}, :source "(defn\n interleave\n \"Returns a lazy seq of the first item in each coll, then the second etc.\"\n ([] ())\n ([c1] (lazy-seq c1))\n ([c1 c2]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2)]\n    (when\n     (and s1 s2)\n     (cons\n      (first s1)\n      (cons (first s2) (interleave (rest s1) (rest s2))))))))\n ([c1 c2 & colls]\n  (lazy-seq\n   (let\n    [ss (map seq (conj colls c2 c1))]\n    (when\n     (every? identity ss)\n     (concat (map first ss) (apply interleave (map rest ss))))))))\n"} {:sym map?, :meta {:doc "Return true if x satisfies IMap", :arglists ([x])}, :source "(defn\n map?\n \"Return true if x satisfies IMap\"\n [x]\n (if (nil? x) false (satisfies? IMap x)))\n"} {:sym m3-C1, :meta {}, :source "(def m3-C1 (int 3432918353))\n"} {:sym get, :meta {:doc "Returns the value mapped to key, not-found or nil if key not present.", :arglists [[o k] [o k not-found]]}, :source "(defn\n get\n \"Returns the value mapped to key, not-found or nil if key not present.\"\n ([o k]\n  (when-not\n   (nil? o)\n   (cond\n    (implements? ILookup o)\n    (-lookup o k)\n    (array? o)\n    (when (and (some? k) (< k (.-length o))) (aget o (int k)))\n    (string? o)\n    (when (and (some? k) (< k (.-length o))) (.charAt o (int k)))\n    (native-satisfies? ILookup o)\n    (-lookup o k)\n    :else\n    nil)))\n ([o k not-found]\n  (if-not\n   (nil? o)\n   (cond\n    (implements? ILookup o)\n    (-lookup o k not-found)\n    (array? o)\n    (if\n     (and (some? k) (>= k 0) (< k (.-length o)))\n     (aget o (int k))\n     not-found)\n    (string? o)\n    (if\n     (and (some? k) (>= k 0) (< k (.-length o)))\n     (.charAt o (int k))\n     not-found)\n    (native-satisfies? ILookup o)\n    (-lookup o k not-found)\n    :else\n    not-found)\n   not-found)))\n"} {:sym identity, :meta {:doc "Returns its argument.", :arglists ([x])}, :source "(defn identity \"Returns its argument.\" [x] x)\n"} {:sym into, :meta {:doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :arglists [[] [to] [to from] [to xform from]]}, :source "(defn\n into\n \"Returns a new coll consisting of to-coll with all of the items of\\n  from-coll conjoined. A transducer may be supplied.\"\n ([] [])\n ([to] to)\n ([to from]\n  (if-not\n   (nil? to)\n   (if\n    (implements? IEditableCollection to)\n    (-with-meta\n     (persistent! (reduce -conj! (transient to) from))\n     (meta to))\n    (reduce -conj to from))\n   (reduce conj () from)))\n ([to xform from]\n  (if\n   (implements? IEditableCollection to)\n   (-with-meta\n    (persistent! (transduce xform conj! (transient to) from))\n    (meta to))\n   (transduce xform conj to from))))\n"} {:sym long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :source "(defn\n long\n \"Coerce to long by stripping decimal places. Identical to `int'.\"\n [x]\n (fix x))\n"} {:sym double, :meta {:doc nil, :arglists ([x])}, :source "(defn double [x] x)\n"} {:sym volatile?, :meta {:doc "Returns true if x is a volatile.", :arglists ([x])}, :source "(defn\n volatile?\n \"Returns true if x is a volatile.\"\n [x]\n (instance? Volatile x))\n"} {:sym -key, :meta {:doc "Returns the key of the map entry.", :arglists ([coll])}, :protocol IMapEntry} {:sym nfirst, :meta {:doc "Same as (next (first x))", :arglists ([coll])}, :source "(defn nfirst \"Same as (next (first x))\" [coll] (next (first coll)))\n"} {:sym meta, :meta {:doc "Returns the metadata of obj, returns nil if there is no metadata.", :arglists ([o])}, :source "(defn\n meta\n \"Returns the metadata of obj, returns nil if there is no metadata.\"\n [o]\n (when (and (not (nil? o)) (satisfies? IMeta o)) (-meta o)))\n"} {:sym -kv-reduce, :meta {:doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :arglists ([coll f init])}, :protocol IKVReduce} {:sym IHash, :meta {:doc "Protocol for adding hashing functionality to a type."}, :methods (-hash)} {:sym bit-and-not, :meta {:doc "Bitwise and with complement", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-and-not\n \"Bitwise and with complement\"\n ([x y] (cljs.core/bit-and-not x y))\n ([x y & more] (reduce bit-and-not (cljs.core/bit-and-not x y) more)))\n"} {:sym var?, :meta {:doc "Returns true if v is of type cljs.core.Var", :arglists ([v])}, :source "(defn\n var?\n \"Returns true if v is of type cljs.core.Var\"\n [v]\n (instance? cljs.core.Var v))\n"} {:sym -comparator, :meta {:doc "Returns the comparator for coll.", :arglists ([coll])}, :protocol ISorted} {:sym unchecked-add-int, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-add-int\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/unchecked-add-int x y))\n ([x y & more]\n  (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))\n"} {:sym hash-ordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :source "(defn\n hash-ordered-coll\n \"Returns the hash code, consistent with =, for an external ordered\\n   collection implementing Iterable.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [coll]\n (loop\n  [n 0 hash-code 1 coll (seq coll)]\n  (if-not\n   (nil? coll)\n   (recur\n    (inc n)\n    (bit-or (+ (imul 31 hash-code) (hash (first coll))) 0)\n    (next coll))\n   (mix-collection-hash hash-code n))))\n"} {:sym IEquiv, :meta {:doc "Protocol for adding value comparison functionality to a type."}, :methods (-equiv)} {:sym cycle, :meta {:doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :arglists ([coll])}, :source "(defn\n cycle\n \"Returns a lazy (infinite!) sequence of repetitions of the items in coll.\"\n [coll]\n (lazy-seq (when-let [s (seq coll)] (concat s (cycle s)))))\n"} {:sym -deref, :meta {:doc "Returns the value of the reference o.", :arglists ([o])}, :protocol IDeref} {:sym empty?, :meta {:doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :arglists ([coll])}, :source "(defn\n empty?\n \"Returns true if coll has no items - same as (not (seq coll)).\\n  Please use the idiom (seq x) rather than (not (empty? x))\"\n [coll]\n (or (nil? coll) (not (seq coll))))\n"} {:sym short, :meta {:doc nil, :arglists ([x])}, :source "(defn short [x] x)\n"} {:sym -chunked-first, :meta {:doc "Returns the first chunk in coll.", :arglists ([coll])}, :protocol IChunkedSeq} {:sym filterv, :meta {:doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.", :arglists ([pred coll])}, :source "(defn\n filterv\n \"Returns a vector of the items in coll for which\\n  (pred item) returns true. pred must be free of side-effects.\"\n [pred coll]\n (->\n  (reduce (fn [v o] (if (pred o) (conj! v o) v)) (transient []) coll)\n  persistent!))\n"} {:sym hash, :meta {:doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =.", :arglists ([o])}, :source "(defn\n hash\n \"Returns the hash code of its argument. Note this is the hash code\\n   consistent with =.\"\n [o]\n (cond\n  (implements? IHash o)\n  (bit-xor (-hash o) 0)\n  (number? o)\n  (if\n   (js/isFinite o)\n   (js-mod (Math/floor o) 2147483647)\n   (case o ##Inf 2146435072 ##-Inf -1048576 2146959360))\n  (true? o)\n  1231\n  (false? o)\n  1237\n  (string? o)\n  (m3-hash-int (hash-string o))\n  (instance? js/Date o)\n  (bit-xor (.valueOf o) 0)\n  (nil? o)\n  0\n  :else\n  (bit-xor (-hash o) 0)))\n"} {:sym quot, :meta {:doc "quot[ient] of dividing numerator by denominator.", :arglists ([n d])}, :source "(defn\n quot\n \"quot[ient] of dividing numerator by denominator.\"\n [n d]\n (let [rem (js-mod n d)] (fix (/ (- n rem) d))))\n"} {:sym unchecked-double, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-double [x] x)\n"} {:sym ranged-iterator, :meta {:doc nil, :arglists ([v start end])}, :source "(defn\n ranged-iterator\n [v start end]\n (let\n  [i start]\n  (RangedIterator.\n   i\n   (- i (js-mod i 32))\n   (when (< start (count v)) (unchecked-array-for v i))\n   v\n   start\n   end)))\n"} {:sym ITransientVector, :meta {:doc "Protocol for adding vector functionality to transient collections."}, :methods (-assoc-n! -pop!)} {:sym longs, :meta {:doc nil, :arglists ([x])}, :source "(defn longs [x] x)\n"} {:sym not=, :meta {:doc "Same as (not (= obj1 obj2))", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n not=\n \"Same as (not (= obj1 obj2))\"\n ([x] false)\n ([x y] (not (= x y)))\n ([x y & more] (not (apply = x y more))))\n"} {:sym set-print-err-fn!, :meta {:doc "Set *print-err-fn* to f.", :arglists ([f])}, :source "(defn\n set-print-err-fn!\n \"Set *print-err-fn* to f.\"\n [f]\n (set! *print-err-fn* f))\n"} {:sym string?, :meta {:doc "Returns true if x is a JavaScript string.", :arglists ([x])}, :source "(defn\n string?\n \"Returns true if x is a JavaScript string.\"\n [x]\n (goog/isString x))\n"} {:sym es6-iterator, :meta {:doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll.", :arglists ([coll])}, :source "(defn\n es6-iterator\n \"EXPERIMENTAL: Return a ES2015 compatible iterator for coll.\"\n [coll]\n (ES6Iterator. (seq coll)))\n"} {:sym m3-C2, :meta {}, :source "(def m3-C2 (int 461845907))\n"} {:sym *print-newline*, :meta {:doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}, :source "(def *print-newline* true)\n"} {:sym unchecked-multiply-int, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-multiply-int\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/unchecked-multiply-int x y))\n ([x y & more]\n  (reduce\n   unchecked-multiply-int\n   (cljs.core/unchecked-multiply-int x y)\n   more)))\n"} {:sym chunk-rest, :meta {:doc nil, :arglists ([s])}, :source "(defn chunk-rest [s] (-chunked-rest s))\n"} {:sym double?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :source "(defn\n double?\n \"Returns true for JavaScript numbers, false otherwise.\"\n [x]\n (number? x))\n"} {:sym vec, :meta {:doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified.", :arglists ([coll])}, :source "(defn\n vec\n \"Creates a new vector containing the contents of coll. JavaScript arrays\\n  will be aliased and should not be modified.\"\n [coll]\n (if\n  (array? coll)\n  (.fromArray PersistentVector coll true)\n  (-persistent!\n   (reduce -conj! (-as-transient (.-EMPTY PersistentVector)) coll))))\n"} {:sym *print-meta*, :meta {:doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}, :source "(def *print-meta* false)\n"} {:sym -notify-watches, :meta {:doc "Calls all watchers with this, oldval and newval.", :arglists ([this oldval newval])}, :protocol IWatchable} {:sym int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :source "(defn int \"Coerce to int by stripping decimal places.\" [x] (bit-or x 0))\n"} {:sym second, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :source "(defn second \"Same as (first (next x))\" [coll] (first (next coll)))\n"} {:sym IEditableCollection, :meta {:doc "Protocol for collections which can transformed to transients."}, :methods (-as-transient)} {:sym hash-combine, :meta {:doc nil, :arglists ([seed hash])}, :source "(defn\n hash-combine\n [seed hash]\n (bit-xor\n  seed\n  (+ hash 2654435769 (bit-shift-left seed 6) (bit-shift-right seed 2))))\n"} {:sym >, :meta {:doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n >\n \"Returns non-nil if nums are in monotonically decreasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/> x y))\n ([x y & more]\n  (if\n   (cljs.core/> x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/> y (first more)))\n   false)))\n"} {:sym -name, :meta {:doc "Returns the name String of x.", :arglists ([x])}, :protocol INamed} {:sym int?, :meta {:doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long.", :arglists ([x])}, :source "(defn\n int?\n \"Return true if x satisfies integer? or is an instance of goog.math.Integer\\n   or goog.math.Long.\"\n [x]\n (or\n  (integer? x)\n  (instance? goog.math.Integer x)\n  (instance? goog.math.Long x)))\n"} {:sym associative?, :meta {:doc "Returns true if coll implements Associative", :arglists ([x])}, :source "(defn\n associative?\n \"Returns true if coll implements Associative\"\n [x]\n (satisfies? IAssociative x))\n"} {:sym unchecked-int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :source "(defn\n unchecked-int\n \"Coerce to int by stripping decimal places.\"\n [x]\n (fix x))\n"} {:sym js-keys, :meta {:doc "Return the JavaScript keys for an object.", :arglists ([obj])}, :source "(defn\n js-keys\n \"Return the JavaScript keys for an object.\"\n [obj]\n (gobject/getKeys obj))\n"} {:sym inst-ms*, :meta {:doc nil, :arglists ([inst])}, :protocol Inst} {:sym keyword?, :meta {:doc "Return true if x is a Keyword", :arglists ([x])}, :source "(defn\n keyword?\n \"Return true if x is a Keyword\"\n [x]\n (instance? Keyword x))\n"} {:sym array-iter, :meta {:doc nil, :arglists ([x])}, :source "(defn array-iter [x] (ArrayIter. x 0))\n"} {:sym -rseq, :meta {:doc "Returns a seq of the items in coll in reversed order.", :arglists ([coll])}, :protocol IReversible} {:sym unchecked-multiply, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-multiply\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/unchecked-multiply x y))\n ([x y & more]\n  (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))\n"} {:sym even?, :meta {:doc "Returns true if n is even, throws an exception if n is not an integer", :arglists ([n])}, :source "(defn\n even?\n \"Returns true if n is even, throws an exception if n is not an integer\"\n [n]\n (if\n  (integer? n)\n  (zero? (bit-and n 1))\n  (throw (js/Error. (str \"Argument must be an integer: \" n)))))\n"} {:sym es6-iterator-seq, :meta {:doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.", :arglists ([iter])}, :source "(defn\n es6-iterator-seq\n \"EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.\"\n [iter]\n (let\n  [v (.next iter)]\n  (if (.-done v) () (ES6IteratorSeq. (.-value v) iter nil))))\n"} {:sym unchecked-dec, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :source "(defn\n unchecked-dec\n \"Returns a number one less than x, an int.\"\n [x]\n (cljs.core/unchecked-dec x))\n"} {:sym Inst, :meta {:doc nil}, :methods (inst-ms*)} {:sym double-array, :meta {:doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n double-array\n \"Creates an array of doubles. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (double-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym spread, :meta {:doc nil, :arglists ([arglist])}, :source "(defn\n spread\n [arglist]\n (when-not\n  (nil? arglist)\n  (let\n   [n (next arglist)]\n   (if\n    (nil? n)\n    (seq (first arglist))\n    (cons (first arglist) (spread n))))))\n"} {:sym rseq, :meta {:doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :arglists ([rev])}, :source "(defn\n rseq\n \"Returns, in constant time, a seq of the items in rev (which\\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil\"\n [rev]\n (-rseq rev))\n"} {:sym IReset, :meta {:doc "Protocol for adding resetting functionality."}, :methods (-reset!)} {:sym IEmptyableCollection, :meta {:doc "Protocol for creating an empty collection."}, :methods (-empty)} {:sym *print-fn-bodies*, :meta {:doc "*print-fns-bodies* controls whether functions print their source or\n    only their names."}, :source "(def *print-fn-bodies* false)\n"} {:sym float, :meta {:doc nil, :arglists ([x])}, :source "(defn float [x] x)\n"} {:sym IRecord, :meta {:doc "Marker interface indicating a record object"}, :methods ()} {:sym concat, :meta {:doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :arglists [[] [x] [x y] [x y & zs]]}, :source "(defn\n concat\n \"Returns a lazy seq representing the concatenation of the elements in the supplied colls.\"\n ([] (lazy-seq nil))\n ([x] (lazy-seq x))\n ([x y]\n  (lazy-seq\n   (let\n    [s (seq x)]\n    (if\n     s\n     (if\n      (chunked-seq? s)\n      (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n      (cons (first s) (concat (rest s) y)))\n     y))))\n ([x y & zs]\n  (let\n   [cat\n    (fn\n     cat\n     [xys zs]\n     (lazy-seq\n      (let\n       [xys (seq xys)]\n       (if\n        xys\n        (if\n         (chunked-seq? xys)\n         (chunk-cons (chunk-first xys) (cat (chunk-rest xys) zs))\n         (cons (first xys) (cat (rest xys) zs)))\n        (when zs (cat (first zs) (next zs)))))))]\n   (cat (concat x y) zs))))\n"} {:sym IDerefWithTimeout, :meta {:doc nil}, :methods (-deref-with-timeout)} {:sym symbol, :meta {:doc "Returns a Symbol with the given namespace and name.", :arglists [[name] [ns name]]}, :source "(defn\n symbol\n \"Returns a Symbol with the given namespace and name.\"\n ([name]\n  (if\n   (symbol? name)\n   name\n   (let\n    [idx (.indexOf name \"/\")]\n    (if\n     (< idx 1)\n     (symbol nil name)\n     (symbol\n      (.substring name 0 idx)\n      (.substring name (inc idx) (. name -length)))))))\n ([ns name]\n  (let\n   [sym-str (if-not (nil? ns) (str ns \"/\" name) name)]\n   (Symbol. ns name sym-str nil nil))))\n"} {:sym to-array-2d, :meta {:doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :arglists ([coll])}, :source "(defn\n to-array-2d\n \"Returns a (potentially-ragged) 2-dimensional array\\n  containing the contents of coll.\"\n [coll]\n (let\n  [ret (make-array (count coll))]\n  (loop\n   [i 0 xs (seq coll)]\n   (when-not\n    (nil? xs)\n    (aset ret i (to-array (first xs)))\n    (recur (inc i) (next xs))))\n  ret))\n"} {:sym mod, :meta {:doc "Modulus of num and div. Truncates toward negative infinity.", :arglists ([n d])}, :source "(defn\n mod\n \"Modulus of num and div. Truncates toward negative infinity.\"\n [n d]\n (js-mod (+ (js-mod n d) d) d))\n"} {:sym ISet, :meta {:doc "Protocol for adding set functionality to a collection."}, :methods (-disjoin)} {:sym pop, :meta {:doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :arglists ([coll])}, :source "(defn\n pop\n \"For a list or queue, returns a new list/queue without the first\\n  item, for a vector, returns a new vector without the last item.\\n  Note - not the same as next/butlast.\"\n [coll]\n (when-not (nil? coll) (-pop coll)))\n"} {:sym IPending, :meta {:doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq."}, :methods (-realized?)} {:sym -entry-key, :meta {:doc "Returns the key for entry.", :arglists ([coll entry])}, :protocol ISorted} {:sym dissoc!, :meta {:doc "Returns a transient map that doesn't contain a mapping for key(s).", :arglists [[tcoll key] [tcoll key & ks]]}, :source "(defn\n dissoc!\n \"Returns a transient map that doesn't contain a mapping for key(s).\"\n ([tcoll key] (-dissoc! tcoll key))\n ([tcoll key & ks]\n  (let\n   [ntcoll (-dissoc! tcoll key)]\n   (if ks (recur ntcoll (first ks) (next ks)) ntcoll))))\n"} {:sym indexed?, :meta {:doc "Returns true if coll implements nth in constant time", :arglists ([x])}, :source "(defn\n indexed?\n \"Returns true if coll implements nth in constant time\"\n [x]\n (satisfies? IIndexed x))\n"} {:sym -, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n -\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/- x))\n ([x y] (cljs.core/- x y))\n ([x y & more] (reduce - (cljs.core/- x y) more)))\n"} {:sym -equiv, :meta {:doc "Returns true if o and other are equal, false otherwise.", :arglists ([o other])}, :protocol IEquiv} {:sym assoc!, :meta {:doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :arglists [[tcoll key val] [tcoll key val & kvs]]}, :source "(defn\n assoc!\n \"When applied to a transient map, adds mapping of key(s) to\\n  val(s). When applied to a transient vector, sets the val at index.\\n  Note - index must be <= (count vector). Returns coll.\"\n ([tcoll key val] (-assoc! tcoll key val))\n ([tcoll key val & kvs]\n  (let\n   [ntcoll (-assoc! tcoll key val)]\n   (if\n    kvs\n    (recur ntcoll (first kvs) (second kvs) (nnext kvs))\n    ntcoll))))\n"} {:sym reduce-kv, :meta {:doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :arglists [[f init coll]]}, :source "(defn\n reduce-kv\n \"Reduces an associative collection. f should be a function of 3\\n  arguments. Returns the result of applying f to init, the first key\\n  and the first value in coll, then applying f to that result and the\\n  2nd key and value, etc. If coll contains no entries, returns init\\n  and f is not called. Note that reduce-kv is supported on vectors,\\n  where the keys will be the ordinals.\"\n ([f init coll] (if-not (nil? coll) (-kv-reduce coll f init) init)))\n"} {:sym reset!, :meta {:doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value.", :arglists ([a new-value])}, :source "(defn\n reset!\n \"Sets the value of atom to newval without regard for the\\n  current value. Returns new-value.\"\n [a new-value]\n (if\n  (instance? Atom a)\n  (let\n   [validate (.-validator a)]\n   (when-not\n    (nil? validate)\n    (when-not\n     (validate new-value)\n     (throw (js/Error. \"Validator rejected reference state\"))))\n   (let\n    [old-value (.-state a)]\n    (set! (.-state a) new-value)\n    (when-not\n     (nil? (.-watches a))\n     (-notify-watches a old-value new-value))\n    new-value))\n  (-reset! a new-value)))\n"} {:sym Fn, :meta {:doc "Marker protocol"}, :methods ()} {:sym ffirst, :meta {:doc "Same as (first (first x))", :arglists ([coll])}, :source "(defn ffirst \"Same as (first (first x))\" [coll] (first (first coll)))\n"} {:sym counted?, :meta {:doc "Returns true if coll implements count in constant time", :arglists ([x])}, :source "(defn\n counted?\n \"Returns true if coll implements count in constant time\"\n [x]\n (satisfies? ICounted x))\n"} {:sym assoc-in, :meta {:doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :arglists ([m [k & ks] v])}, :source "(defn\n assoc-in\n \"Associates a value in a nested associative structure, where ks is a\\n  sequence of keys and v is the new value and returns a new nested structure.\\n  If any levels do not exist, hash-maps will be created.\"\n [m [k & ks] v]\n (if ks (assoc m k (assoc-in (get m k) ks v)) (assoc m k v)))\n"} {:sym bit-test, :meta {:doc "Test bit at index n", :arglists ([x n])}, :source "(defn bit-test \"Test bit at index n\" [x n] (cljs.core/bit-test x n))\n"} {:sym ISwap, :meta {:doc "Protocol for adding swapping functionality."}, :methods (-swap!)} {:sym zero?, :meta {:doc "Returns true if num is zero, else false", :arglists ([x])}, :source "(defn\n zero?\n \"Returns true if num is zero, else false\"\n [x]\n (cljs.core/zero? x))\n"} {:sym simple-keyword?, :meta {:doc "Return true if x is a keyword without a namespace", :arglists ([x])}, :source "(defn\n simple-keyword?\n \"Return true if x is a keyword without a namespace\"\n [x]\n (and (keyword? x) (nil? (namespace x))))\n"} {:sym *main-cli-fn*, :meta {:doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments"}, :source "(def *main-cli-fn* nil)\n"} {:sym -assoc-n, :meta {:doc "Returns a new vector with value val added at position n.", :arglists ([coll n val])}, :protocol IVector} {:sym unchecked-dec-int, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :source "(defn\n unchecked-dec-int\n \"Returns a number one less than x, an int.\"\n [x]\n (cljs.core/unchecked-dec-int x))\n"} {:sym persistent!, :meta {:doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :arglists ([tcoll])}, :source "(defn\n persistent!\n \"Returns a new, persistent version of the transient collection, in\\n  constant time. The transient collection cannot be used after this\\n  call, any such use will throw an exception.\"\n [tcoll]\n (-persistent! tcoll))\n"} {:sym set-print-fn!, :meta {:doc "Set *print-fn* to f.", :arglists ([f])}, :source "(defn set-print-fn! \"Set *print-fn* to f.\" [f] (set! *print-fn* f))\n"} {:sym nnext, :meta {:doc "Same as (next (next x))", :arglists ([coll])}, :source "(defn nnext \"Same as (next (next x))\" [coll] (next (next coll)))\n"} {:sym not-every?, :meta {:doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :arglists ([pred coll])}, :source "(defn\n not-every?\n \"Returns false if (pred x) is logical true for every x in\\n  coll, else true.\"\n [pred coll]\n (not (every? pred coll)))\n"} {:sym rem, :meta {:doc "remainder of dividing numerator by denominator.", :arglists ([n d])}, :source "(defn\n rem\n \"remainder of dividing numerator by denominator.\"\n [n d]\n (let [q (quot n d)] (- n (* d q))))\n"} {:sym ifind?, :meta {:doc "Returns true if coll implements IFind", :arglists ([x])}, :source "(defn\n ifind?\n \"Returns true if coll implements IFind\"\n [x]\n (satisfies? IFind x))\n"} {:sym some, :meta {:doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :arglists ([pred coll])}, :source "(defn\n some\n \"Returns the first logical true value of (pred x) for any x in coll,\\n  else nil.  One common idiom is to use a set as pred, for example\\n  this will return :fred if :fred is in the sequence, otherwise nil:\\n  (some #{:fred} coll)\"\n [pred coll]\n (when (seq coll) (or (pred (first coll)) (recur pred (next coll)))))\n"} {:sym INamed, :meta {:doc "Protocol for adding a name."}, :methods (-name -namespace)} {:sym IReduce, :meta {:doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce."}, :methods (-reduce)} {:sym neg-int?, :meta {:doc "Return true if x satisfies int? and is negative.", :arglists ([x])}, :source "(defn\n neg-int?\n \"Return true if x satisfies int? and is negative.\"\n [x]\n (cond\n  (integer? x)\n  (neg? x)\n  (instance? goog.math.Integer x)\n  (.isNegative x)\n  (instance? goog.math.Long x)\n  (.isNegative x)\n  :else\n  false))\n"} {:sym drop, :meta {:doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :arglists [[n] [n coll]]}, :source "(defn\n drop\n \"Returns a lazy sequence of all but the first n items in coll.\\n  Returns a stateful transducer when no collection is provided.\"\n ([n]\n  {:pre [(number? n)]}\n  (fn\n   [rf]\n   (let\n    [na (volatile! n)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [n @na]\n       (vswap! na dec)\n       (if (pos? n) result (rf result input))))))))\n ([n coll]\n  {:pre [(number? n)]}\n  (let\n   [step\n    (fn\n     [n coll]\n     (let\n      [s (seq coll)]\n      (if (and (pos? n) s) (recur (dec n) (rest s)) s)))]\n   (lazy-seq (step n coll)))))\n"} {:sym js-obj, :meta {:doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :arglists [[] [& keyvals]]}, :source "(defn\n js-obj\n \"Create JavaSript object from an even number arguments representing\\n  interleaved keys and values.\"\n ([] (cljs.core/js-obj))\n ([& keyvals] (apply gobject/create keyvals)))\n"} {:sym ITransientCollection, :meta {:doc "Protocol for adding basic functionality to transient collections."}, :methods (-conj! -persistent!)} {:sym nth, :meta {:doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :arglists [[coll n] [coll n not-found]]}, :source "(defn\n nth\n \"Returns the value at the index. get returns nil if index out of\\n  bounds, nth throws an exception unless not-found is supplied.  nth\\n  also works for strings, arrays, regex Matchers and Lists, and,\\n  in O(n) time, for sequences.\"\n ([coll n]\n  (cond\n   (not (number? n))\n   (throw (js/Error. \"Index argument to nth must be a number\"))\n   (nil? coll)\n   coll\n   (implements? IIndexed coll)\n   (-nth coll n)\n   (array? coll)\n   (if\n    (and (>= n 0) (< n (.-length coll)))\n    (aget coll n)\n    (throw (js/Error. \"Index out of bounds\")))\n   (string? coll)\n   (if\n    (and (>= n 0) (< n (.-length coll)))\n    (.charAt coll n)\n    (throw (js/Error. \"Index out of bounds\")))\n   (implements? ISeq coll)\n   (linear-traversal-nth coll n)\n   (native-satisfies? IIndexed coll)\n   (-nth coll n)\n   :else\n   (throw\n    (js/Error.\n     (str\n      \"nth not supported on this type \"\n      (type->str (type coll)))))))\n ([coll n not-found]\n  (cond\n   (not (number? n))\n   (throw (js/Error. \"Index argument to nth must be a number.\"))\n   (nil? coll)\n   not-found\n   (implements? IIndexed coll)\n   (-nth coll n not-found)\n   (array? coll)\n   (if (and (>= n 0) (< n (.-length coll))) (aget coll n) not-found)\n   (string? coll)\n   (if (and (>= n 0) (< n (.-length coll))) (.charAt coll n) not-found)\n   (implements? ISeq coll)\n   (linear-traversal-nth coll n not-found)\n   (native-satisfies? IIndexed coll)\n   (-nth coll n not-found)\n   :else\n   (throw\n    (js/Error.\n     (str\n      \"nth not supported on this type \"\n      (type->str (type coll))))))))\n"} {:sym sorted?, :meta {:doc "Returns true if coll satisfies ISorted", :arglists ([x])}, :source "(defn\n sorted?\n \"Returns true if coll satisfies ISorted\"\n [x]\n (satisfies? ISorted x))\n"} {:sym nil?, :meta {:doc "Returns true if x is nil, false otherwise.", :arglists ([x])}, :source "(defn\n nil?\n \"Returns true if x is nil, false otherwise.\"\n [x]\n (coercive-= x nil))\n"} {:sym split-at, :meta {:doc "Returns a vector of [(take n coll) (drop n coll)]", :arglists ([n coll])}, :source "(defn\n split-at\n \"Returns a vector of [(take n coll) (drop n coll)]\"\n [n coll]\n [(take n coll) (drop n coll)])\n"} {:sym not-native, :meta {}, :source "(def not-native nil)\n"} {:sym bit-and, :meta {:doc "Bitwise and", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-and\n \"Bitwise and\"\n ([x y] (cljs.core/bit-and x y))\n ([x y & more] (reduce bit-and (cljs.core/bit-and x y) more)))\n"} {:sym bounded-count, :meta {:doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq", :arglists ([n coll])}, :source "(defn\n bounded-count\n \"If coll is counted? returns its count, else will count at most the first n\\n   elements of coll using its seq\"\n {:added \"1.9\"}\n [n coll]\n (if\n  (counted? coll)\n  (count coll)\n  (loop\n   [i 0 s (seq coll)]\n   (if (and (not (nil? s)) (< i n)) (recur (inc i) (next s)) i))))\n"} {:sym update, :meta {:doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :arglists [[m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]]}, :source "(defn\n update\n \"'Updates' a value in an associative structure, where k is a\\n  key and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  structure.  If the key does not exist, nil is passed as the old value.\"\n ([m k f] (assoc m k (f (get m k))))\n ([m k f x] (assoc m k (f (get m k) x)))\n ([m k f x y] (assoc m k (f (get m k) x y)))\n ([m k f x y z] (assoc m k (f (get m k) x y z)))\n ([m k f x y z & more] (assoc m k (apply f (get m k) x y z more))))\n"} {:sym list*, :meta {:doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :arglists [[args] [a args] [a b args] [a b c args] [a b c d & more]]}, :source "(defn\n list*\n \"Creates a new list containing the items prepended to the rest, the\\n  last of which will be treated as a sequence.\"\n ([args] (seq args))\n ([a args] (cons a args))\n ([a b args] (cons a (cons b args)))\n ([a b c args] (cons a (cons b (cons c args))))\n ([a b c d & more] (cons a (cons b (cons c (cons d (spread more)))))))\n"} {:sym update-in, :meta {:doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :arglists [[m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]]}, :source "(defn\n update-in\n \"'Updates' a value in a nested associative structure, where ks is a\\n  sequence of keys and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  nested structure.  If any levels do not exist, hash-maps will be\\n  created.\"\n ([m [k & ks] f]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f))\n   (assoc m k (f (get m k)))))\n ([m [k & ks] f a]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a))\n   (assoc m k (f (get m k) a))))\n ([m [k & ks] f a b]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a b))\n   (assoc m k (f (get m k) a b))))\n ([m [k & ks] f a b c]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a b c))\n   (assoc m k (f (get m k) a b c))))\n ([m [k & ks] f a b c & args]\n  (if\n   ks\n   (assoc m k (apply update-in (get m k) ks f a b c args))\n   (assoc m k (apply f (get m k) a b c args)))))\n"} {:sym ensure-reduced, :meta {:doc "If x is already reduced?, returns it, else returns (reduced x)", :arglists ([x])}, :source "(defn\n ensure-reduced\n \"If x is already reduced?, returns it, else returns (reduced x)\"\n [x]\n (if (reduced? x) x (reduced x)))\n"} {:sym instance?, :meta {:doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false", :arglists ([c x])}, :source "(defn\n instance?\n \"Evaluates x and tests if it is an instance of the type\\n  c. Returns true or false\"\n [c x]\n (cljs.core/instance? c x))\n"} {:sym mix-collection-hash, :meta {:doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([hash-basis count])}, :source "(defn\n mix-collection-hash\n \"Mix final collection hash for ordered or unordered collections.\\n   hash-basis is the combined collection hash, count is the number\\n   of elements included in the basis. Note this is the hash code\\n   consistent with =, different from .hashCode.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [hash-basis count]\n (let\n  [h1 m3-seed k1 (m3-mix-K1 hash-basis) h1 (m3-mix-H1 h1 k1)]\n  (m3-fmix h1 count)))\n"} {:sym unchecked-add, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-add\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/unchecked-add x y))\n ([x y & more]\n  (reduce unchecked-add (cljs.core/unchecked-add x y) more)))\n"} {:sym transformer-iterator, :meta {:doc nil, :arglists ([xform sourceIter multi])}, :source "(defn\n transformer-iterator\n [xform sourceIter multi]\n (let\n  [iterator\n   (TransformerIterator. EMPTY NONE false nil sourceIter multi)]\n  (set!\n   (.-xf iterator)\n   (xform\n    (fn\n     ([] nil)\n     ([acc] acc)\n     ([acc o]\n      (set! (.-buffer iterator) (.add (.-buffer iterator) o))\n      acc))))\n  iterator))\n"} {:sym not, :meta {:doc "Returns true if x is logical false, false otherwise.", :arglists ([x])}, :source "(defn\n not\n \"Returns true if x is logical false, false otherwise.\"\n [x]\n (cond (nil? x) true (false? x) true :else false))\n"} {:sym -vreset!, :meta {:doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :arglists ([o new-value])}, :protocol IVolatile} {:sym with-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :arglists ([o meta])}, :source "(defn\n with-meta\n \"Returns an object of the same type and value as obj, with\\n  map m as its metadata.\"\n [o meta]\n (if\n  (goog/isFunction o)\n  (MetaFn. o meta)\n  (when-not (nil? o) (-with-meta o meta))))\n"} {:sym unreduced, :meta {:doc "If x is reduced?, returns (deref x), else returns x", :arglists ([x])}, :source "(defn\n unreduced\n \"If x is reduced?, returns (deref x), else returns x\"\n [x]\n (if (reduced? x) (deref x) x))\n"} {:sym record?, :meta {:doc "Return true if x satisfies IRecord", :arglists ([x])}, :source "(defn\n record?\n \"Return true if x satisfies IRecord\"\n [x]\n (satisfies? IRecord x))\n"} {:sym type, :meta {:doc "Return x's constructor.", :arglists ([x])}, :source "(defn\n type\n \"Return x's constructor.\"\n [x]\n (when-not (nil? x) (.-constructor x)))\n"} {:sym identical?, :meta {:doc "Tests if 2 arguments are the same object", :arglists ([x y])}, :source "(defn\n identical?\n \"Tests if 2 arguments are the same object\"\n [x y]\n (cljs.core/identical? x y))\n"} {:sym -namespace, :meta {:doc "Returns the namespace String of x.", :arglists ([x])}, :protocol INamed} {:sym unchecked-divide-int, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-divide-int\n \"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"\n ([x] (unchecked-divide-int 1 x))\n ([x y] (cljs.core/divide x y))\n ([x y & more]\n  (reduce unchecked-divide-int (unchecked-divide-int x y) more)))\n"} {:sym *out*, :meta {}, :source "(def *out* nil)\n"} {:sym hash-string, :meta {:doc nil, :arglists ([k])}, :source "(defn\n hash-string\n [k]\n (when\n  (> string-hash-cache-count 255)\n  (set! string-hash-cache (js-obj))\n  (set! string-hash-cache-count 0))\n (if\n  (nil? k)\n  0\n  (let\n   [h (unchecked-get string-hash-cache k)]\n   (if (number? h) h (add-to-string-hash-cache k)))))\n"} {:sym set-validator!, :meta {:doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :arglists ([iref val])}, :source "(defn\n set-validator!\n \"Sets the validator-fn for an atom. validator-fn must be nil or a\\n  side-effect-free fn of one argument, which will be passed the intended\\n  new state on any state change. If the new state is unacceptable, the\\n  validator-fn should return false or throw an Error. If the current state\\n  is not acceptable to the new validator, an Error will be thrown and the\\n  validator will not be changed.\"\n [iref val]\n (when\n  (and (some? val) (not (val (-deref iref))))\n  (throw (js/Error. \"Validator rejected reference state\")))\n (set! (.-validator iref) val))\n"} {:sym ident?, :meta {:doc "Return true if x is a symbol or keyword", :arglists ([x])}, :source "(defn\n ident?\n \"Return true if x is a symbol or keyword\"\n [x]\n (or (keyword? x) (symbol? x)))\n"} {:sym -meta, :meta {:doc "Returns the metadata of object o.", :arglists ([o])}, :protocol IMeta} {:sym swap!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :arglists [[a f] [a f x] [a f x y] [a f x y & more]]}, :source "(defn\n swap!\n \"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.  Returns\\n  the value that was swapped in.\"\n ([a f]\n  (if (instance? Atom a) (reset! a (f (.-state a))) (-swap! a f)))\n ([a f x]\n  (if (instance? Atom a) (reset! a (f (.-state a) x)) (-swap! a f x)))\n ([a f x y]\n  (if\n   (instance? Atom a)\n   (reset! a (f (.-state a) x y))\n   (-swap! a f x y)))\n ([a f x y & more]\n  (if\n   (instance? Atom a)\n   (reset! a (apply f (.-state a) x y more))\n   (-swap! a f x y more))))\n"} {:sym -chunked-next, :meta {:doc "Returns a new collection of coll without the first chunk.", :arglists ([coll])}, :protocol IChunkedNext} {:sym unchecked-subtract, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-subtract\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/unchecked-subtract x))\n ([x y] (cljs.core/unchecked-subtract x y))\n ([x y & more]\n  (reduce unchecked-subtract (cljs.core/unchecked-subtract x y) more)))\n"} {:sym IMap, :meta {:doc "Protocol for adding mapping functionality to collections."}, :methods (-dissoc)} {:sym cloneable?, :meta {:doc "Return true if x implements ICloneable protocol.", :arglists ([value])}, :source "(defn\n cloneable?\n \"Return true if x implements ICloneable protocol.\"\n [value]\n (satisfies? ICloneable value))\n"} {:sym qualified-ident?, :meta {:doc "Return true if x is a symbol or keyword with a namespace", :arglists ([x])}, :source "(defn\n qualified-ident?\n \"Return true if x is a symbol or keyword with a namespace\"\n [x]\n (boolean (and (ident? x) (namespace x) true)))\n"} {:sym hash-string*, :meta {:doc nil, :arglists ([s])}, :source "(defn\n hash-string*\n [s]\n (if-not\n  (nil? s)\n  (let\n   [len (.-length s)]\n   (if\n    (pos? len)\n    (loop\n     [i 0 hash 0]\n     (if\n      (< i len)\n      (recur (inc i) (+ (imul 31 hash) (.charCodeAt s i)))\n      hash))\n    0))\n  0))\n"} {:sym true?, :meta {:doc "Returns true if x is the value true, false otherwise.", :arglists ([x])}, :source "(defn\n true?\n \"Returns true if x is the value true, false otherwise.\"\n [x]\n (cljs.core/true? x))\n"} {:sym array, :meta {:doc "Creates a new javascript array.\n@param {...*} var_args", :arglists ([var-args])}, :source "(defn\n array\n \"Creates a new javascript array.\\n@param {...*} var_args\"\n [var-args]\n (let\n  [a (js/Array. (alength (cljs.core/js-arguments)))]\n  (loop\n   [i 0]\n   (if\n    (< i (alength a))\n    (do (aset a i (aget (cljs.core/js-arguments) i)) (recur (inc i)))\n    a))))\n"} {:sym -peek, :meta {:doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :arglists ([coll])}, :protocol IStack} {:sym ISeq, :meta {:doc "Protocol for collections to provide access to their items as sequences."}, :methods (-first -rest)} {:sym empty, :meta {:doc "Returns an empty collection of the same category as coll, or nil", :arglists ([coll])}, :source "(defn\n empty\n \"Returns an empty collection of the same category as coll, or nil\"\n [coll]\n (when-not (nil? coll) (-empty coll)))\n"} {:sym volatile!, :meta {:doc "Creates and returns a Volatile with an initial value of val.", :arglists ([val])}, :source "(defn\n volatile!\n \"Creates and returns a Volatile with an initial value of val.\"\n [val]\n (Volatile. val))\n"} {:sym /, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n /\n \"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"\n ([x] (/ 1 x))\n ([x y] (cljs.core/divide x y))\n ([x y & more] (reduce / (/ x y) more)))\n"} {:sym bit-or, :meta {:doc "Bitwise or", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-or\n \"Bitwise or\"\n ([x y] (cljs.core/bit-or x y))\n ([x y & more] (reduce bit-or (cljs.core/bit-or x y) more)))\n"} {:sym m3-fmix, :meta {:doc nil, :arglists ([h1 len])}, :source "(defn\n m3-fmix\n [h1 len]\n (as->\n  (int h1)\n  h1\n  (bit-xor h1 len)\n  (bit-xor h1 (unsigned-bit-shift-right h1 16))\n  (imul h1 (int 2246822507))\n  (bit-xor h1 (unsigned-bit-shift-right h1 13))\n  (imul h1 (int 3266489909))\n  (bit-xor h1 (unsigned-bit-shift-right h1 16))))\n"} {:sym vector, :meta {:doc "Creates a new vector containing the args.", :arglists ([& args])}, :source "(defn\n vector\n \"Creates a new vector containing the args.\"\n [& args]\n (if\n  (and (instance? IndexedSeq args) (zero? (.-i args)))\n  (.fromArray PersistentVector (.-arr args) true)\n  (vec args)))\n"} {:sym >=, :meta {:doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n >=\n \"Returns non-nil if nums are in monotonically non-increasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/>= x y))\n ([x y & more]\n  (if\n   (cljs.core/>= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/>= y (first more)))\n   false)))\n"} {:sym drop-last, :meta {:doc "Return a lazy sequence of all but the last n (default 1) items in coll", :arglists [[s] [n s]]}, :source "(defn\n drop-last\n \"Return a lazy sequence of all but the last n (default 1) items in coll\"\n ([s] (drop-last 1 s))\n ([n s] (map (fn [x _] x) s (drop n s))))\n"} {:sym object?, :meta {:doc "Returns true if x's constructor is Object", :arglists ([x])}, :source "(defn\n object?\n \"Returns true if x's constructor is Object\"\n [x]\n (if-not (nil? x) (identical? (.-constructor x) js/Object) false))\n"} {:sym not-empty, :meta {:doc "If coll is empty, returns nil, else coll", :arglists ([coll])}, :source "(defn\n not-empty\n \"If coll is empty, returns nil, else coll\"\n [coll]\n (when (seq coll) coll))\n"} {:sym partition, :meta {:doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :arglists [[n coll] [n step coll] [n step pad coll]]}, :source "(defn\n partition\n \"Returns a lazy sequence of lists of n items each, at offsets step\\n  apart. If step is not supplied, defaults to n, i.e. the partitions\\n  do not overlap. If a pad collection is supplied, use its elements as\\n  necessary to complete last partition up to n items. In case there are\\n  not enough padding elements, return a partition with less than n items.\"\n ([n coll] (partition n n coll))\n ([n step coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (let\n     [p (take n s)]\n     (when\n      (== n (count p))\n      (cons p (partition n step (drop step s))))))))\n ([n step pad coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (let\n     [p (take n s)]\n     (if\n      (== n (count p))\n      (cons p (partition n step pad (drop step s)))\n      (list (take n (concat p pad)))))))))\n"} {:sym DEMUNGE_PATTERN, :meta {}, :source "(def DEMUNGE_PATTERN nil)\n"} {:sym IAssociative, :meta {:doc "Protocol for adding associativity to collections."}, :methods (-assoc -contains-key?)} {:sym bit-flip, :meta {:doc "Flip bit at index n", :arglists ([x n])}, :source "(defn bit-flip \"Flip bit at index n\" [x n] (cljs.core/bit-flip x n))\n"} {:sym long-array, :meta {:doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n long-array\n \"Creates an array of longs. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (long-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym ISeqable, :meta {:doc "Protocol for adding the ability to a type to be transformed into a sequence."}, :methods (-seq)} {:sym js-mod, :meta {:doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :arglists ([n d])}, :source "(defn\n js-mod\n \"Modulus of num and div with original javascript behavior. i.e. bug for negative numbers\"\n [n d]\n (cljs.core/js-mod n d))\n"} {:sym integer?, :meta {:doc "Returns true if n is a JavaScript number with no decimal part.", :arglists ([n])}, :source "(defn\n integer?\n \"Returns true if n is a JavaScript number with no decimal part.\"\n [n]\n (and\n  (number? n)\n  (not (js/isNaN n))\n  (not (identical? n js/Infinity))\n  (== (js/parseFloat n) (js/parseInt n 10))))\n"} {:sym mapv, :meta {:doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :arglists [[f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]]}, :source "(defn\n mapv\n \"Returns a vector consisting of the result of applying f to the\\n  set of first items of each coll, followed by applying f to the set\\n  of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments.\"\n ([f coll]\n  (->\n   (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n   persistent!))\n ([f c1 c2] (into [] (map f c1 c2)))\n ([f c1 c2 c3] (into [] (map f c1 c2 c3)))\n ([f c1 c2 c3 & colls] (into [] (apply map f c1 c2 c3 colls))))\n"} {:sym infinite?, :meta {:doc "Returns true for Infinity and -Infinity values.", :arglists ([x])}, :source "(defn\n infinite?\n \"Returns true for Infinity and -Infinity values.\"\n [x]\n (or\n  (identical? x js/Number.POSITIVE_INFINITY)\n  (identical? x js/Number.NEGATIVE_INFINITY)))\n"} {:sym ISequential, :meta {:doc "Marker interface indicating a persistent collection of sequential items"}, :methods ()} {:sym equiv-map, :meta {:doc "Test map equivalence. Returns true if x equals y, otherwise returns false.", :arglists ([x y])}, :source "(defn\n equiv-map\n \"Test map equivalence. Returns true if x equals y, otherwise returns false.\"\n [x y]\n (boolean\n  (when\n   (and (map? y) (not (record? y)))\n   (when\n    (== (count x) (count y))\n    (if\n     (satisfies? IKVReduce x)\n     (reduce-kv\n      (fn\n       [_ k v]\n       (if (= (get y k never-equiv) v) true (reduced false)))\n      true\n      x)\n     (every?\n      (fn [xkv] (= (get y (first xkv) never-equiv) (second xkv)))\n      x))))))\n"} {:sym object-array, :meta {:doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n object-array\n \"Creates an array of objects. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (object-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym seq-iter, :meta {:doc nil, :arglists ([coll])}, :source "(defn seq-iter [coll] (SeqIter. INIT coll))\n"} {:sym IChunkedSeq, :meta {:doc "Protocol for accessing a collection as sequential chunks."}, :methods (-chunked-first -chunked-rest)} {:sym -next, :meta {:doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :arglists ([coll])}, :protocol INext} {:sym flatten, :meta {:doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :arglists ([x])}, :source "(defn\n flatten\n \"Takes any nested combination of sequential things (lists, vectors,\\n  etc.) and returns their contents as a single, flat sequence.\\n  (flatten nil) returns nil.\"\n [x]\n (filter\n  (fn* [p1__19425#] (not (sequential? p1__19425#)))\n  (rest (tree-seq sequential? seq x))))\n"} {:sym -dissoc, :meta {:doc "Returns a new collection of coll without the mapping for key k.", :arglists ([coll k])}, :protocol IMap} {:sym doubles, :meta {:doc nil, :arglists ([x])}, :source "(defn doubles [x] x)\n"} {:sym -contains-key?, :meta {:doc "Returns true if k is a key in coll.", :arglists ([coll k])}, :protocol IAssociative} {:sym ifn?, :meta {:doc "Returns true if f returns true for fn? or satisfies IFn.", :arglists ([f])}, :source "(defn\n ifn?\n \"Returns true if f returns true for fn? or satisfies IFn.\"\n [f]\n (or (fn? f) (satisfies? IFn f)))\n"} {:sym IAtom, :meta {:doc "Marker protocol indicating an atom."}, :methods ()} {:sym nat-int?, :meta {:doc "Return true if x satisfies int? and is a natural integer value.", :arglists ([x])}, :source "(defn\n nat-int?\n \"Return true if x satisfies int? and is a natural integer value.\"\n [x]\n (cond\n  (integer? x)\n  (or (not (neg? x)) (zero? x))\n  (instance? goog.math.Integer x)\n  (or (not (.isNegative x)) (.isZero x))\n  (instance? goog.math.Long x)\n  (or (not (.isNegative x)) (.isZero x))\n  :else\n  false))\n"} {:sym IWatchable, :meta {:doc "Protocol for types that can be watched. Currently only implemented by Atom."}, :methods (-add-watch -notify-watches -remove-watch)} {:sym subvec, :meta {:doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :arglists [[v start] [v start end]]}, :source "(defn\n subvec\n \"Returns a persistent vector of the items in vector from\\n  start (inclusive) to end (exclusive).  If end is not supplied,\\n  defaults to (count vector). This operation is O(1) and very fast, as\\n  the resulting vector shares structure with the original and no\\n  trimming is done.\"\n ([v start] (subvec v start (count v)))\n ([v start end]\n  (assert (and (not (nil? start)) (not (nil? end))))\n  (build-subvec nil v start end nil)))\n"} {:sym -pop!, :meta {:doc "Returns tcoll with the last item removed from it.", :arglists ([tcoll])}, :protocol ITransientVector} {:sym partial, :meta {:doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :arglists [[f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]]}, :source "(defn\n partial\n \"Takes a function f and fewer than the normal arguments to f, and\\n  returns a fn that takes a variable number of additional args. When\\n  called, the returned function calls f with args + additional args.\"\n ([f] f)\n ([f arg1]\n  (fn\n   ([] (f arg1))\n   ([x] (f arg1 x))\n   ([x y] (f arg1 x y))\n   ([x y z] (f arg1 x y z))\n   ([x y z & args] (apply f arg1 x y z args))))\n ([f arg1 arg2]\n  (fn\n   ([] (f arg1 arg2))\n   ([x] (f arg1 arg2 x))\n   ([x y] (f arg1 arg2 x y))\n   ([x y z] (f arg1 arg2 x y z))\n   ([x y z & args] (apply f arg1 arg2 x y z args))))\n ([f arg1 arg2 arg3]\n  (fn\n   ([] (f arg1 arg2 arg3))\n   ([x] (f arg1 arg2 arg3 x))\n   ([x y] (f arg1 arg2 arg3 x y))\n   ([x y z] (f arg1 arg2 arg3 x y z))\n   ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))\n ([f arg1 arg2 arg3 & more]\n  (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))\n"} {:sym chunked-seq?, :meta {:doc "Return true if x is satisfies IChunkedSeq.", :arglists ([x])}, :source "(defn\n chunked-seq?\n \"Return true if x is satisfies IChunkedSeq.\"\n [x]\n (implements? IChunkedSeq x))\n"} {:sym replicate, :meta {:doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs.", :arglists ([n x])}, :source "(defn\n replicate\n \"DEPRECATED: Use 'repeat' instead.\\n  Returns a lazy seq of n xs.\"\n [n x]\n (take n (repeat x)))\n"} {:sym reduced, :meta {:doc "Wraps x in a way such that a reduce will terminate with the value x", :arglists ([x])}, :source "(defn\n reduced\n \"Wraps x in a way such that a reduce will terminate with the value x\"\n [x]\n (Reduced. x))\n"} {:sym ITransientSet, :meta {:doc "Protocol for adding set functionality to a transient collection."}, :methods (-disjoin!)} {:sym unchecked-byte, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-byte [x] x)\n"} {:sym every-pred, :meta {:doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :arglists [[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]]}, :source "(defn\n every-pred\n \"Takes a set of predicates and returns a function f that returns true if all of its\\n  composing predicates return a logical true value against all of its arguments, else it returns\\n  false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical false result against the original predicates.\"\n ([p]\n  (fn\n   ep1\n   ([] true)\n   ([x] (boolean (p x)))\n   ([x y] (boolean (and (p x) (p y))))\n   ([x y z] (boolean (and (p x) (p y) (p z))))\n   ([x y z & args] (boolean (and (ep1 x y z) (every? p args))))))\n ([p1 p2]\n  (fn\n   ep2\n   ([] true)\n   ([x] (boolean (and (p1 x) (p2 x))))\n   ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n   ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n   ([x y z & args]\n    (boolean\n     (and\n      (ep2 x y z)\n      (every?\n       (fn* [p1__19412#] (and (p1 p1__19412#) (p2 p1__19412#)))\n       args))))))\n ([p1 p2 p3]\n  (fn\n   ep3\n   ([] true)\n   ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n   ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n   ([x y z]\n    (boolean\n     (and\n      (p1 x)\n      (p2 x)\n      (p3 x)\n      (p1 y)\n      (p2 y)\n      (p3 y)\n      (p1 z)\n      (p2 z)\n      (p3 z))))\n   ([x y z & args]\n    (boolean\n     (and\n      (ep3 x y z)\n      (every?\n       (fn*\n        [p1__19413#]\n        (and (p1 p1__19413#) (p2 p1__19413#) (p3 p1__19413#)))\n       args))))))\n ([p1 p2 p3 & ps]\n  (let\n   [ps (list* p1 p2 p3 ps)]\n   (fn\n    epn\n    ([] true)\n    ([x] (every? (fn* [p1__19414#] (p1__19414# x)) ps))\n    ([x y]\n     (every?\n      (fn* [p1__19415#] (and (p1__19415# x) (p1__19415# y)))\n      ps))\n    ([x y z]\n     (every?\n      (fn*\n       [p1__19416#]\n       (and (p1__19416# x) (p1__19416# y) (p1__19416# z)))\n      ps))\n    ([x y z & args]\n     (boolean\n      (and\n       (epn x y z)\n       (every? (fn* [p1__19417#] (every? p1__19417# args)) ps))))))))\n"} {:sym missing-protocol, :meta {:doc nil, :arglists ([proto obj])}, :source "(defn\n missing-protocol\n [proto obj]\n (let\n  [ty\n   (type obj)\n   ty\n   (if\n    (and ty (.-cljs$lang$type ty))\n    (.-cljs$lang$ctorStr ty)\n    (goog/typeOf obj))]\n  (js/Error.\n   (.join\n    (array\n     \"No protocol method \"\n     proto\n     \" defined for type \"\n     ty\n     \": \"\n     obj)\n    \"\"))))\n"} {:sym load-file, :meta {:doc nil, :arglists ([file])}, :source "(defn\n load-file\n [file]\n (when-not js/COMPILED (cljs.core/load-file* file)))\n"} {:sym distinct?, :meta {:doc "Returns true if no two of the arguments are =", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n distinct?\n \"Returns true if no two of the arguments are =\"\n ([x] true)\n ([x y] (not (= x y)))\n ([x y & more]\n  (if\n   (not (= x y))\n   (loop\n    [s #{x y} xs more]\n    (let\n     [x (first xs) etc (next xs)]\n     (if xs (if (contains? s x) false (recur (conj s x) etc)) true)))\n   false)))\n"} {:sym pos-int?, :meta {:doc "Return true if x satisfies int? and is positive.", :arglists ([x])}, :source "(defn\n pos-int?\n \"Return true if x satisfies int? and is positive.\"\n [x]\n (cond\n  (integer? x)\n  (pos? x)\n  (instance? goog.math.Integer x)\n  (and (not (.isNegative x)) (not (.isZero x)))\n  (instance? goog.math.Long x)\n  (and (not (.isNegative x)) (not (.isZero x)))\n  :else\n  false))\n"} {:sym unchecked-short, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-short [x] x)\n"} {:sym odd?, :meta {:doc "Returns true if n is odd, throws an exception if n is not an integer", :arglists ([n])}, :source "(defn\n odd?\n \"Returns true if n is odd, throws an exception if n is not an integer\"\n [n]\n (not (even? n)))\n"} {:sym reduceable?, :meta {:doc "Returns true if coll satisfies IReduce", :arglists ([x])}, :source "(defn\n reduceable?\n \"Returns true if coll satisfies IReduce\"\n [x]\n (satisfies? IReduce x))\n"} {:sym string-hash-cache, :meta {}, :source "(def string-hash-cache (js-obj))\n"} {:sym inc, :meta {:doc "Returns a number one greater than num.", :arglists ([x])}, :source "(defn\n inc\n \"Returns a number one greater than num.\"\n [x]\n (cljs.core/+ x 1))\n"} {:sym type->str, :meta {:doc nil, :arglists ([ty])}, :source "(defn type->str [ty] (if-let [s (.-cljs$lang$ctorStr ty)] s (str ty)))\n"} {:sym bit-clear, :meta {:doc "Clear bit at index n", :arglists ([x n])}, :source "(defn bit-clear \"Clear bit at index n\" [x n] (cljs.core/bit-clear x n))\n"} {:sym filter, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n filter\n \"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns true. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"\n ([pred]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input] (if (pred input) (rf result input) result)))))\n ([pred coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes\n       [i size]\n       (when (pred (-nth c i)) (chunk-append b (-nth c i))))\n      (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n     (let\n      [f (first s) r (rest s)]\n      (if (pred f) (cons f (filter pred r)) (filter pred r))))))))\n"} {:sym -assoc-n!, :meta {:doc "Returns tcoll with value val added at position n.", :arglists ([tcoll n val])}, :protocol ITransientVector} {:sym IWithMeta, :meta {:doc "Protocol for adding metadata to an object."}, :methods (-with-meta)} {:sym list, :meta {:doc "Creates a new list containing the items.", :arglists ([& xs])}, :source "(defn\n list\n \"Creates a new list containing the items.\"\n [& xs]\n (let\n  [arr\n   (if\n    (and (instance? IndexedSeq xs) (zero? (.-i xs)))\n    (.-arr xs)\n    (let\n     [arr (array)]\n     (loop\n      [xs xs]\n      (if-not\n       (nil? xs)\n       (do (.push arr (-first xs)) (recur (-next xs)))\n       arr))))]\n  (loop\n   [i (alength arr) r ()]\n   (if (> i 0) (recur (dec i) (-conj r (aget arr (dec i)))) r))))\n"} {:sym +, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n +\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/+ x y))\n ([x y & more] (reduce + (cljs.core/+ x y) more)))\n"} {:sym aset, :meta {:doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val.", :arglists [[array idx val] [array idx idx2 & idxv]]}, :source "(defn\n aset\n \"Sets the value at the index/indices. Works on JavaScript arrays.\\n  Returns val.\"\n ([array idx val] (cljs.core/aset array idx val))\n ([array idx idx2 & idxv] (apply aset (aget array idx) idx2 idxv)))\n"} {:sym int-rotate-left, :meta {:doc nil, :arglists ([x n])}, :source "(defn\n int-rotate-left\n [x n]\n (bit-or (bit-shift-left x n) (unsigned-bit-shift-right x (- n))))\n"} {:sym keyword, :meta {:doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :arglists [[name] [ns name]]}, :source "(defn\n keyword\n \"Returns a Keyword with the given namespace and name.  Do not use :\\n  in the keyword strings, it will be added automatically.\"\n ([name]\n  (cond\n   (keyword? name)\n   name\n   (symbol? name)\n   (Keyword.\n    (cljs.core/namespace name)\n    (cljs.core/name name)\n    (.-str name)\n    nil)\n   (string? name)\n   (let\n    [parts (.split name \"/\")]\n    (if\n     (== (alength parts) 2)\n     (Keyword. (aget parts 0) (aget parts 1) name nil)\n     (Keyword. nil (aget parts 0) name nil)))))\n ([ns name]\n  (let\n   [ns\n    (cond\n     (keyword? ns)\n     (cljs.core/name ns)\n     (symbol? ns)\n     (cljs.core/name ns)\n     :else\n     ns)\n    name\n    (cond\n     (keyword? name)\n     (cljs.core/name name)\n     (symbol? name)\n     (cljs.core/name name)\n     :else\n     name)]\n   (Keyword. ns name (str (when ns (str ns \"/\")) name) nil))))\n"} {:sym *ns*, :meta {:doc "Var bound to the current namespace. Only used for bootstrapping."}, :source "(def *ns* nil)\n"} {:sym *assert*, :meta {}, :source "(def *assert* true)\n"} {:sym ICollection, :meta {:doc "Protocol for adding to a collection."}, :methods (-conj)} {:sym chars, :meta {:doc nil, :arglists ([x])}, :source "(defn chars [x] x)\n"} {:sym next, :meta {:doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :arglists ([coll])}, :source "(defn\n next\n \"Returns a seq of the items after the first. Calls seq on its\\n  argument.  If there are no more items, returns nil\"\n [coll]\n (when-not\n  (nil? coll)\n  (if (implements? INext coll) (-next coll) (seq (rest coll)))))\n"} {:sym ASeq, :meta {:doc "Marker protocol indicating an array sequence."}, :methods ()} {:sym IFn, :meta {:doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2"}, :methods (-invoke)} {:sym -reset!, :meta {:doc "Sets the value of o to new-value.", :arglists ([o new-value])}, :protocol IReset} {:sym -rest, :meta {:doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :arglists ([coll])}, :protocol ISeq} {:sym nil-iter, :meta {:doc nil, :arglists ([])}, :source "(defn\n nil-iter\n []\n (reify\n  Object\n  (hasNext [_] false)\n  (next [_] (js/Error. \"No such element\"))\n  (remove [_] (js/Error. \"Unsupported operation\"))))\n"} {:sym false?, :meta {:doc "Returns true if x is the value false, false otherwise.", :arglists ([x])}, :source "(defn\n false?\n \"Returns true if x is the value false, false otherwise.\"\n [x]\n (cljs.core/false? x))\n"} {:sym *print-readably*, :meta {:doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}, :source "(def *print-readably* true)\n"} {:sym ints, :meta {:doc nil, :arglists ([x])}, :source "(defn ints [x] x)\n"} {:sym some-fn, :meta {:doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :arglists [[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]]}, :source "(defn\n some-fn\n \"Takes a set of predicates and returns a function f that returns the first logical true value\\n  returned by one of its composing predicates against any of its arguments, else it returns\\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical true result against the original predicates.\"\n ([p]\n  (fn\n   sp1\n   ([] nil)\n   ([x] (p x))\n   ([x y] (or (p x) (p y)))\n   ([x y z] (or (p x) (p y) (p z)))\n   ([x y z & args] (or (sp1 x y z) (some p args)))))\n ([p1 p2]\n  (fn\n   sp2\n   ([] nil)\n   ([x] (or (p1 x) (p2 x)))\n   ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n   ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n   ([x y z & args]\n    (or\n     (sp2 x y z)\n     (some\n      (fn* [p1__19418#] (or (p1 p1__19418#) (p2 p1__19418#)))\n      args)))))\n ([p1 p2 p3]\n  (fn\n   sp3\n   ([] nil)\n   ([x] (or (p1 x) (p2 x) (p3 x)))\n   ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n   ([x y z]\n    (or\n     (p1 x)\n     (p2 x)\n     (p3 x)\n     (p1 y)\n     (p2 y)\n     (p3 y)\n     (p1 z)\n     (p2 z)\n     (p3 z)))\n   ([x y z & args]\n    (or\n     (sp3 x y z)\n     (some\n      (fn*\n       [p1__19419#]\n       (or (p1 p1__19419#) (p2 p1__19419#) (p3 p1__19419#)))\n      args)))))\n ([p1 p2 p3 & ps]\n  (let\n   [ps (list* p1 p2 p3 ps)]\n   (fn\n    spn\n    ([] nil)\n    ([x] (some (fn* [p1__19420#] (p1__19420# x)) ps))\n    ([x y]\n     (some (fn* [p1__19421#] (or (p1__19421# x) (p1__19421# y))) ps))\n    ([x y z]\n     (some\n      (fn*\n       [p1__19422#]\n       (or (p1__19422# x) (p1__19422# y) (p1__19422# z)))\n      ps))\n    ([x y z & args]\n     (or\n      (spn x y z)\n      (some (fn* [p1__19423#] (some p1__19423# args)) ps)))))))\n"} {:sym *flush-on-newline*, :meta {:doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}, :source "(def *flush-on-newline* true)\n"} {:sym to-array, :meta {:doc "Naive impl of to-array as a start.", :arglists ([s])}, :source "(defn\n to-array\n \"Naive impl of to-array as a start.\"\n [s]\n (let\n  [ary (array)]\n  (loop\n   [s (seq s)]\n   (if-not (nil? s) (do (. ary push (first s)) (recur (next s))) ary))))\n"} {:sym list?, :meta {:doc "Returns true if x implements IList", :arglists ([x])}, :source "(defn\n list?\n \"Returns true if x implements IList\"\n [x]\n (satisfies? IList x))\n"} {:sym array?, :meta {:doc "Returns true if x is a JavaScript array.", :arglists ([x])}, :source "(defn\n array?\n \"Returns true if x is a JavaScript array.\"\n [x]\n (if\n  (identical? *target* \"nodejs\")\n  (.isArray js/Array x)\n  (instance? js/Array x)))\n"} {:sym simple-ident?, :meta {:doc "Return true if x is a symbol or keyword without a namespace", :arglists ([x])}, :source "(defn\n simple-ident?\n \"Return true if x is a symbol or keyword without a namespace\"\n [x]\n (and (ident? x) (nil? (namespace x))))\n"} {:sym clone, :meta {:doc "Clone the supplied value which must implement ICloneable.", :arglists ([value])}, :source "(defn\n clone\n \"Clone the supplied value which must implement ICloneable.\"\n [value]\n (-clone value))\n"} {:sym bit-not, :meta {:doc "Bitwise complement", :arglists ([x])}, :source "(defn bit-not \"Bitwise complement\" [x] (cljs.core/bit-not x))\n"} {:sym byte, :meta {:doc nil, :arglists ([x])}, :source "(defn byte [x] x)\n"} {:sym max, :meta {:doc "Returns the greatest of the nums.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n max\n \"Returns the greatest of the nums.\"\n ([x] x)\n ([x y] (cljs.core/max x y))\n ([x y & more] (reduce max (cljs.core/max x y) more)))\n"} {:sym IComparable, :meta {:doc "Protocol for values that can be compared."}, :methods (-compare)} {:sym ==, :meta {:doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n ==\n \"Returns non-nil if nums all have the equivalent\\n  value, otherwise false. Behavior on non nums is\\n  undefined.\"\n ([x] true)\n ([x y] (-equiv x y))\n ([x y & more]\n  (if\n   (== x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (== y (first more)))\n   false)))\n"} {:sym count, :meta {:doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :arglists ([coll])}, :source "(defn\n count\n \"Returns the number of items in the collection. (count nil) returns\\n  0.  Also works on strings, arrays, and Maps\"\n [coll]\n (if-not\n  (nil? coll)\n  (cond\n   (implements? ICounted coll)\n   (-count coll)\n   (array? coll)\n   (alength coll)\n   (string? coll)\n   (.-length coll)\n   (implements? ISeqable coll)\n   (accumulating-seq-count coll)\n   :else\n   (-count coll))\n  0))\n"} {:sym -disjoin!, :meta {:doc "Returns tcoll without v.", :arglists ([tcoll v])}, :protocol ITransientSet} {:sym *loaded-libs*, :meta {}, :source "(defonce *loaded-libs* nil)\n"} {:sym apply, :meta {:doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :arglists [[f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]]}, :source "(defn\n apply\n \"Applies fn f to the argument list formed by prepending intervening arguments to args.\"\n ([f args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (bounded-count (inc fixed-arity) args)]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc args)\n     (.cljs$lang$applyTo f args)))\n   (apply-to-simple f (seq args))))\n ([f x args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (inc (bounded-count fixed-arity args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x (seq args))))\n ([f x y args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x y args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 2 (bounded-count (dec fixed-arity) args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x y (seq args))))\n ([f x y z args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x y z args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 3 (bounded-count (- fixed-arity 2) args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x y z (seq args))))\n ([f a b c d & args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [spread-args\n     (spread args)\n     arglist\n     (cons a (cons b (cons c (cons d spread-args))))\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 4 (bounded-count (- fixed-arity 3) spread-args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f a b c d (spread args)))))\n"} {:sym add-to-string-hash-cache, :meta {:doc nil, :arglists ([k])}, :source "(defn\n add-to-string-hash-cache\n [k]\n (let\n  [h (hash-string* k)]\n  (gobject/set string-hash-cache k h)\n  (set! string-hash-cache-count (inc string-hash-cache-count))\n  h))\n"} {:sym IChunkedNext, :meta {:doc "Protocol for accessing the chunks of a collection."}, :methods (-chunked-next)} {:sym interpose, :meta {:doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :arglists [[sep] [sep coll]]}, :source "(defn\n interpose\n \"Returns a lazy seq of the elements of coll separated by sep.\\n  Returns a stateful transducer when no collection is provided.\"\n ([sep]\n  (fn\n   [rf]\n   (let\n    [started (volatile! false)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (if\n       @started\n       (let\n        [sepr (rf result sep)]\n        (if (reduced? sepr) sepr (rf sepr input)))\n       (do (vreset! started true) (rf result input))))))))\n ([sep coll] (drop 1 (interleave (repeat sep) coll))))\n"} {:sym deref, :meta {:doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?.", :arglists ([o])}, :source "(defn\n deref\n \"Also reader macro: @var/@atom/@delay. Returns the\\n   most-recently-committed value of ref. When applied to a var\\n   or atom, returns its current state. When applied to a delay, forces\\n   it if not already forced. See also - realized?.\"\n [o]\n (-deref o))\n"} {:sym assoc, :meta {:doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :arglists [[coll k v] [coll k v & kvs]]}, :source "(defn\n assoc\n \"assoc[iate]. When applied to a map, returns a new map of the\\n   same (hashed/sorted) type, that contains the mapping of key(s) to\\n   val(s). When applied to a vector, returns a new vector that\\n   contains val at index.\"\n ([coll k v] (if-not (nil? coll) (-assoc coll k v) (array-map k v)))\n ([coll k v & kvs]\n  (let\n   [ret (assoc coll k v)]\n   (if kvs (recur ret (first kvs) (second kvs) (nnext kvs)) ret))))\n"} {:sym transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :source "(defn\n transient\n \"Returns a new, transient version of the collection, in constant time.\"\n [coll]\n (-as-transient coll))\n"} {:sym -disjoin, :meta {:doc "Returns a new collection of coll that does not contain v.", :arglists ([coll v])}, :protocol ISet} {:sym chunk-cons, :meta {:doc nil, :arglists ([chunk rest])}, :source "(defn\n chunk-cons\n [chunk rest]\n (if (zero? (-count chunk)) rest (ChunkedCons. chunk rest nil nil)))\n"} {:sym drop-while, :meta {:doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n drop-while\n \"Returns a lazy sequence of the items in coll starting from the\\n  first item for which (pred item) returns logical false.  Returns a\\n  stateful transducer when no collection is provided.\"\n ([pred]\n  (fn\n   [rf]\n   (let\n    [da (volatile! true)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [drop? @da]\n       (if\n        (and drop? (pred input))\n        result\n        (do (vreset! da nil) (rf result input)))))))))\n ([pred coll]\n  (let\n   [step\n    (fn\n     [pred coll]\n     (let\n      [s (seq coll)]\n      (if (and s (pred (first s))) (recur pred (rest s)) s)))]\n   (lazy-seq (step pred coll)))))\n"} {:sym IWriter, :meta {:doc "Protocol for writing. Currently only implemented by StringBufferWriter."}, :methods (-flush -write)} {:sym *print-fn*, :meta {:doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed."}, :source "(defonce *print-fn* nil)\n"} {:sym compare, :meta {:doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :arglists ([x y])}, :source "(defn\n compare\n \"Comparator. Returns a negative number, zero, or a positive number\\n  when x is logically 'less than', 'equal to', or 'greater than'\\n  y. Uses IComparable if available and google.array.defaultCompare for objects\\n of the same type and special-cases nil to be less than any other object.\"\n [x y]\n (cond\n  (identical? x y)\n  0\n  (nil? x)\n  -1\n  (nil? y)\n  1\n  (number? x)\n  (if\n   (number? y)\n   (garray/defaultCompare x y)\n   (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))\n  (satisfies? IComparable x)\n  (-compare x y)\n  :else\n  (if\n   (and\n    (or (string? x) (array? x) (true? x) (false? x))\n    (identical? (type x) (type y)))\n   (garray/defaultCompare x y)\n   (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))))\n"} {:sym complement, :meta {:doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :arglists ([f])}, :source "(defn\n complement\n \"Takes a fn f and returns a fn that takes the same arguments as f,\\n  has the same effects, if any, and returns the opposite truth value.\"\n [f]\n (fn\n  ([] (not (f)))\n  ([x] (not (f x)))\n  ([x y] (not (f x y)))\n  ([x y & zs] (not (apply f x y zs)))))\n"} {:sym -assoc!, :meta {:doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :arglists ([tcoll key val])}, :protocol ITransientAssociative} {:sym *print-dup*, :meta {:doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}, :source "(def *print-dup* false)\n"} {:sym string-iter, :meta {:doc nil, :arglists ([x])}, :source "(defn string-iter [x] (StringIter. x 0))\n"} {:sym IDeref, :meta {:doc "Protocol for adding dereference functionality to a reference."}, :methods (-deref)} {:sym sequence, :meta {:doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :arglists [[coll] [xform coll] [xform coll & colls]]}, :source "(defn\n sequence\n \"Coerces coll to a (possibly empty) sequence, if it is not already\\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\\n  transducer is supplied, returns a lazy sequence of applications of\\n  the transform to the items in coll(s), i.e. to the set of first\\n  items of each coll, followed by the set of second\\n  items in each coll, until any one of the colls is exhausted.  Any\\n  remaining items in other colls are ignored. The transform should accept\\n  number-of-colls arguments\"\n ([coll] (if (seq? coll) coll (or (seq coll) ())))\n ([xform coll]\n  (or\n   (chunkIteratorSeq (.create TransformerIterator xform (iter coll)))\n   ()))\n ([xform coll & colls]\n  (or\n   (chunkIteratorSeq\n    (.createMulti\n     TransformerIterator\n     xform\n     (map iter (cons coll colls))))\n   ())))\n"} {:sym constantly, :meta {:doc "Returns a function that takes any number of arguments and returns x.", :arglists ([x])}, :source "(defn\n constantly\n \"Returns a function that takes any number of arguments and returns x.\"\n [x]\n (fn [& args] x))\n"} {:sym chunked-seq, :meta {:doc nil, :arglists [[vec i off] [vec node i off] [vec node i off meta]]}, :source "(defn\n chunked-seq\n ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n ([vec node i off meta] (ChunkedSeq. vec node i off meta nil)))\n"} {:sym ISorted, :meta {:doc "Protocol for a collection which can represent their items\n  in a sorted manner. "}, :methods (-comparator -entry-key -sorted-seq -sorted-seq-from)} {:sym make-array, :meta {:doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.", :arglists [[size] [type size] [type size & more-sizes]]}, :source "(defn\n make-array\n \"Construct a JavaScript array of the specified dimensions. Accepts ignored\\n  type argument for compatibility with Clojure. Note that there is no efficient\\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\\n  will run in polynomial time when called with 3 or more arguments.\"\n ([size] (js/Array. size))\n ([type size] (make-array size))\n ([type size & more-sizes]\n  (let\n   [dims more-sizes dimarray (make-array size)]\n   (dotimes\n    [i (alength dimarray)]\n    (aset dimarray i (apply make-array nil dims)))\n   dimarray)))\n"} {:sym shorts, :meta {:doc nil, :arglists ([x])}, :source "(defn shorts [x] x)\n"} {:sym *unchecked-if*, :meta {}, :source "(def *unchecked-if* false)\n"} {:sym enable-console-print!, :meta {:doc "Set *print-fn* to console.log", :arglists ([])}, :source "(defn\n enable-console-print!\n \"Set *print-fn* to console.log\"\n []\n (set! *print-newline* false)\n (set!\n  *print-fn*\n  (fn\n   [& args]\n   (.apply (.-log js/console) js/console (into-array args))))\n (set!\n  *print-err-fn*\n  (fn\n   [& args]\n   (.apply (.-error js/console) js/console (into-array args))))\n nil)\n"} {:sym -flush, :meta {:doc "Flush writer.", :arglists ([writer])}, :protocol IWriter} {:sym completing, :meta {:doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :arglists [[f] [f cf]]}, :source "(defn\n completing\n \"Takes a reducing function f of 2 args and returns a fn suitable for\\n  transduce by adding an arity-1 signature that calls cf (default -\\n  identity) on the result argument.\"\n ([f] (completing f identity))\n ([f cf] (fn ([] (f)) ([x] (cf x)) ([x y] (f x y)))))\n"} {:sym unchecked-negate-int, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-negate-int [x] (cljs.core/unchecked-negate-int x))\n"} {:sym hash-unordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :source "(defn\n hash-unordered-coll\n \"Returns the hash code, consistent with =, for an external unordered\\n   collection implementing Iterable. For maps, the iterator should\\n   return map entries whose hash is computed as\\n     (hash-ordered-coll [k v]).\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [coll]\n (loop\n  [n 0 hash-code 0 coll (seq coll)]\n  (if-not\n   (nil? coll)\n   (recur\n    (inc n)\n    (bit-or (+ hash-code (hash (first coll))) 0)\n    (next coll))\n   (mix-collection-hash hash-code n))))\n"} {:sym repeat, :meta {:doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :arglists [[x] [n x]]}, :source "(defn\n repeat\n \"Returns a lazy (infinite!, or length n if supplied) sequence of xs.\"\n ([x] (lazy-seq (cons x (repeat x))))\n ([n x] (take n (repeat x))))\n"} {:sym unchecked-inc, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-inc [x] (cljs.core/unchecked-inc x))\n"} {:sym nthnext, :meta {:doc "Returns the nth next of coll, (seq coll) when n is 0.", :arglists ([coll n])}, :source "(defn\n nthnext\n \"Returns the nth next of coll, (seq coll) when n is 0.\"\n [coll n]\n (loop\n  [n n xs (seq coll)]\n  (if (and xs (pos? n)) (recur (dec n) (next xs)) xs)))\n"} {:sym get-validator, :meta {:doc "Gets the validator-fn for a var/ref/agent/atom.", :arglists ([iref])}, :source "(defn\n get-validator\n \"Gets the validator-fn for a var/ref/agent/atom.\"\n [iref]\n (.-validator iref))\n"} {:sym number?, :meta {:doc "Returns true if x is a JavaScript number.", :arglists ([x])}, :source "(defn\n number?\n \"Returns true if x is a JavaScript number.\"\n [x]\n (cljs.core/number? x))\n"} {:sym -conj!, :meta {:doc "Adds value val to tcoll and returns tcoll.", :arglists ([tcoll val])}, :protocol ITransientCollection} {:sym chunk-next, :meta {:doc nil, :arglists ([s])}, :source "(defn\n chunk-next\n [s]\n (if\n  (implements? IChunkedNext s)\n  (-chunked-next s)\n  (seq (-chunked-rest s))))\n"} {:sym not-any?, :meta {:doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :arglists ([pred coll])}, :source "(defn\n not-any?\n \"Returns false if (pred x) is logical true for any x in coll,\\n  else true.\"\n [pred coll]\n (not (some pred coll)))\n"} {:sym into-array, :meta {:doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :arglists [[aseq] [type aseq]]}, :source "(defn\n into-array\n \"Returns an array with components set to the values in aseq. Optional type\\n  argument accepted for compatibility with Clojure.\"\n ([aseq] (into-array nil aseq))\n ([type aseq] (reduce (fn [a x] (.push a x) a) (array) aseq)))\n"} {:sym -hash, :meta {:doc "Returns the hash code of o.", :arglists ([o])}, :protocol IHash} {:sym qualified-symbol?, :meta {:doc "Return true if x is a symbol with a namespace", :arglists ([x])}, :source "(defn\n qualified-symbol?\n \"Return true if x is a symbol with a namespace\"\n [x]\n (boolean (and (symbol? x) (namespace x) true)))\n"} {:sym -dissoc!, :meta {:doc "Returns a new transient collection of tcoll without the mapping for key.", :arglists ([tcoll key])}, :protocol ITransientMap} {:sym chunk-buffer, :meta {:doc nil, :arglists ([capacity])}, :source "(defn chunk-buffer [capacity] (ChunkBuffer. (make-array capacity) 0))\n"} {:sym seqable?, :meta {:doc "Return true if the seq function is supported for s", :arglists ([s])}, :source "(defn\n seqable?\n \"Return true if the seq function is supported for s\"\n [s]\n (or (satisfies? ISeqable s) (array? s) (string? s)))\n"} {:sym symbol?, :meta {:doc "Return true if x is a Symbol", :arglists ([x])}, :source "(defn symbol? \"Return true if x is a Symbol\" [x] (instance? Symbol x))\n"} {:sym m3-hash-unencoded-chars, :meta {:doc nil, :arglists ([in])}, :source "(defn\n m3-hash-unencoded-chars\n [in]\n (let\n  [h1\n   (loop\n    [i 1 h1 m3-seed]\n    (if\n     (< i (.-length in))\n     (recur\n      (+ i 2)\n      (m3-mix-H1\n       h1\n       (m3-mix-K1\n        (bit-or\n         (.charCodeAt in (dec i))\n         (bit-shift-left (.charCodeAt in i) 16)))))\n     h1))\n   h1\n   (if\n    (== (bit-and (.-length in) 1) 1)\n    (bit-xor h1 (m3-mix-K1 (.charCodeAt in (dec (.-length in)))))\n    h1)]\n  (m3-fmix h1 (imul 2 (.-length in)))))\n"} {:sym unchecked-char, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-char [x] x)\n"} {:sym system-time, :meta {:doc "Returns highest resolution time offered by host in milliseconds.", :arglists ([])}, :source "(defn\n system-time\n \"Returns highest resolution time offered by host in milliseconds.\"\n []\n (cond\n  (and (exists? js/performance) (not (nil? (. js/performance -now))))\n  (.now js/performance)\n  (and (exists? js/process) (not (nil? (. js/process -hrtime))))\n  (let\n   [t (.hrtime js/process)]\n   (/ (+ (* (aget t 0) 1.0E9) (aget t 1)) 1000000.0))\n  :else\n  (.getTime (js/Date.))))\n"} {:sym -invoke, :meta {:doc nil, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])}, :protocol IFn} {:sym coll?, :meta {:doc "Returns true if x satisfies ICollection", :arglists ([x])}, :source "(defn\n coll?\n \"Returns true if x satisfies ICollection\"\n [x]\n (if (nil? x) false (satisfies? ICollection x)))\n"} {:sym get-in, :meta {:doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :arglists [[m ks] [m ks not-found]]}, :source "(defn\n get-in\n \"Returns the value in a nested associative structure,\\n  where ks is a sequence of keys. Returns nil if the key is not present,\\n  or the not-found value if supplied.\"\n {:added \"1.2\", :static true}\n ([m ks] (reduce get m ks))\n ([m ks not-found]\n  (loop\n   [sentinel lookup-sentinel m m ks (seq ks)]\n   (if-not\n    (nil? ks)\n    (let\n     [m (get m (first ks) sentinel)]\n     (if\n      (identical? sentinel m)\n      not-found\n      (recur sentinel m (next ks))))\n    m))))\n"} {:sym fnext, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :source "(defn fnext \"Same as (first (next x))\" [coll] (first (next coll)))\n"} {:sym IList, :meta {:doc "Marker interface indicating a persistent list"}, :methods ()} {:sym -val, :meta {:doc "Returns the value of the map entry.", :arglists ([coll])}, :protocol IMapEntry} {:sym bytes, :meta {:doc nil, :arglists ([x])}, :source "(defn bytes [x] x)\n"} {:sym -seq, :meta {:doc "Returns a seq of o, or nil if o is empty.", :arglists ([o])}, :protocol ISeqable}), cljs.pprint ({:sym pprint, :meta {:doc nil, :arglists [[object] [object writer]]}, :source "(defn\n pprint\n ([object]\n  (let\n   [sb (StringBuffer.)]\n   (binding\n    [*out* (StringBufferWriter. sb)]\n    (pprint object *out*)\n    (string-print (str sb)))))\n ([object writer]\n  (with-pretty-writer\n   writer\n   (binding [*print-pretty* true] (write-out object))\n   (if (not (= 0 (get-column *out*))) (-write *out* \\newline)))))\n"} {:sym get-pretty-writer, :meta {:doc "Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be\npreserved across calls, you will want to wrap them with this.\n\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \"~4D~7,vT\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1\n       2      4       8\n       3      9      27\n       4     16      64\n       5     25     125\n       6     36     216\n       7     49     343\n       8     64     512\n       9     81     729\n      10    100    1000", :arglists ([writer])}, :source "(defn\n get-pretty-writer\n \"Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\\nwrite, and cl-format all call it if they need to. However if you want the state to be\\npreserved across calls, you will want to wrap them with this.\\n\\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\\ndo it like in this example:\\n\\n    (defn print-table [aseq column-width]\\n      (binding [*out* (get-pretty-writer *out*)]\\n        (doseq [row aseq]\\n          (doseq [col row]\\n            (cl-format true \\\"~4D~7,vT\\\" col column-width))\\n          (prn))))\\n\\nNow when you run:\\n\\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\\n\\nIt prints a table of squares and cubes for the numbers from 1 to 10:\\n\\n       1      1       1\\n       2      4       8\\n       3      9      27\\n       4     16      64\\n       5     25     125\\n       6     36     216\\n       7     49     343\\n       8     64     512\\n       9     81     729\\n      10    100    1000\"\n [writer]\n (if\n  (pretty-writer? writer)\n  writer\n  (pretty-writer writer *print-right-margin* *print-miser-width*)))\n"} {:sym *print-suppress-namespaces*, :meta {:doc "Don't print namespaces with symbols. This is particularly useful when\npretty printing the results of macro expansions"}, :source "(def *print-suppress-namespaces* nil)\n"} {:sym char-code, :meta {:doc "Convert char to int", :arglists ([c])}, :source "(defn\n char-code\n \"Convert char to int\"\n [c]\n (cond\n  (number? c)\n  c\n  (and (string? c) (== (.-length c) 1))\n  (.charCodeAt c 0)\n  :else\n  (throw (js/Error. \"Argument to char must be a character or number\"))))\n"} {:sym *print-pretty*, :meta {:doc "Bind to true if you want write to use pretty printing"}, :source "(def *print-pretty* true)\n"} {:sym *print-pprint-dispatch*, :meta {:doc "The pretty print dispatch function. Use with-pprint-dispatch or\nset-pprint-dispatch to modify."}, :source "(defonce *print-pprint-dispatch* nil)\n"} {:sym pprint-newline, :meta {:doc "Print a conditional newline to a pretty printing stream. kind specifies if the\n  newline is :linear, :miser, :fill, or :mandatory.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Output is sent to *out* which must be a pretty printing writer.", :arglists ([kind])}, :source "(defn\n pprint-newline\n \"Print a conditional newline to a pretty printing stream. kind specifies if the\\n  newline is :linear, :miser, :fill, or :mandatory.\\n\\n  This function is intended for use when writing custom dispatch functions.\\n\\n  Output is sent to *out* which must be a pretty printing writer.\"\n [kind]\n (check-enumerated-arg kind #{:mandatory :miser :fill :linear})\n (nl *out* kind))\n"} {:sym float?, :meta {:doc "Returns true if n is an float.", :arglists ([n])}, :source "(defn\n float?\n \"Returns true if n is an float.\"\n [n]\n (and\n  (number? n)\n  (not (js/isNaN n))\n  (not (identical? n js/Infinity))\n  (not (== (js/parseFloat n) (js/parseInt n 10)))))\n"} {:sym pprint-tab, :meta {:doc "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative.\n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.", :arglists ([kind colnum colinc])}, :source "(defn\n pprint-tab\n \"Tab at this point in the pretty printing stream. kind specifies whether the tab\\nis :line, :section, :line-relative, or :section-relative.\\n\\nColnum and colinc specify the target column and the increment to move the target\\nforward if the output is already past the original target.\\n\\nThis function is intended for use when writing custom dispatch functions.\\n\\nOutput is sent to *out* which must be a pretty printing writer.\\n\\nTHIS FUNCTION IS NOT YET IMPLEMENTED.\"\n {:added \"1.2\"}\n [kind colnum colinc]\n (check-enumerated-arg\n  kind\n  #{:section :line :line-relative :section-relative})\n (throw (js/Error. \"pprint-tab is not yet implemented\")))\n"} {:sym pprint-set, :meta {}, :source "(def pprint-set (formatter-out \"~<#{~;~@{~w~^ ~:_~}~;}~:>\"))\n"} {:sym print-table, :meta {:doc "Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.", :arglists [[ks rows] [rows]]}, :source "(defn\n print-table\n \"Prints a collection of maps in a textual table. Prints table headings\\n   ks, and then a line of output for each row, corresponding to the keys\\n   in ks. If ks are not specified, use the keys of the first item in rows.\"\n {:added \"1.3\"}\n ([ks rows]\n  (binding\n   [*print-newline*]\n   (when\n    (seq rows)\n    (let\n     [widths\n      (map\n       (fn\n        [k]\n        (apply\n         max\n         (count (str k))\n         (map\n          (fn* [p1__19487#] (count (str (get p1__19487# k))))\n          rows)))\n       ks)\n      spacers\n      (map\n       (fn* [p1__19488#] (apply str (repeat p1__19488# \"-\")))\n       widths)\n      fmt-row\n      (fn\n       [leader divider trailer row]\n       (str\n        leader\n        (apply\n         str\n         (interpose\n          divider\n          (for\n           [[col width]\n            (map\n             vector\n             (map (fn* [p1__19489#] (get row p1__19489#)) ks)\n             widths)]\n           (add-padding width (str col)))))\n        trailer))]\n     (cljs.core/println)\n     (cljs.core/println (fmt-row \"| \" \" | \" \" |\" (zipmap ks ks)))\n     (cljs.core/println (fmt-row \"|-\" \"-+-\" \"-|\" (zipmap ks spacers)))\n     (doseq\n      [row rows]\n      (cljs.core/println (fmt-row \"| \" \" | \" \" |\" row)))))))\n ([rows] (print-table (keys (first rows)) rows)))\n"} {:sym set-pprint-dispatch, :meta {:doc nil, :arglists ([function])}, :source "(defn\n set-pprint-dispatch\n [function]\n (set! *print-pprint-dispatch* function)\n nil)\n"} {:sym fresh-line, :meta {:doc "Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.", :arglists ([])}, :source "(defn\n fresh-line\n \"Make a newline if *out* is not already at the beginning of the line. If *out* is\\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.\"\n []\n (if\n  (satisfies? IDeref *out*)\n  (if (not (= 0 (get-column (:base @@*out*)))) (prn))\n  (prn)))\n"} {:sym pprint-indent, :meta {:doc "Create an indent at this point in the pretty printing stream. This defines how\nfollowing lines are indented. relative-to can be either :block or :current depending\nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", :arglists ([relative-to n])}, :source "(defn\n pprint-indent\n \"Create an indent at this point in the pretty printing stream. This defines how\\nfollowing lines are indented. relative-to can be either :block or :current depending\\nwhether the indent should be computed relative to the start of the logical block or\\nthe current column position. n is an offset.\\n\\nThis function is intended for use when writing custom dispatch functions.\\n\\nOutput is sent to *out* which must be a pretty printing writer.\"\n [relative-to n]\n (check-enumerated-arg relative-to #{:block :current})\n (indent *out* relative-to n))\n"} {:sym *print-radix*, :meta {:doc "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8,\nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the\nradix specifier is in the form #XXr where XX is the decimal value of *print-base* "}, :source "(def *print-radix* nil)\n"} {:sym IPrettyFlush, :meta {:doc nil}, :methods (-ppflush)} {:sym cl-format, :meta {:doc "An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It\nsupports sophisticated formatting of structured data.\n\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\nto a string, format-in is the format control string and the remaining arguments\nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives'\ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\"\n                   (count results) results))\n\nPrints via *print-fn*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \"Common Lisp the\nLanguage, 2nd edition\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\nand in the Common Lisp HyperSpec at\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm", :arglists ([writer format-in & args])}, :source "(defn\n cl-format\n \"An implementation of a Common Lisp compatible format function. cl-format formats its\\narguments to an output stream or string based on the format control string given. It\\nsupports sophisticated formatting of structured data.\\n\\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\\nto a string, format-in is the format control string and the remaining arguments\\nare the data to be formatted.\\n\\nThe format control string is a string to be output with embedded 'format directives'\\ndescribing how to format the various arguments passed in.\\n\\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\\nreturns nil.\\n\\nFor example:\\n (let [results [46 38 22]]\\n        (cl-format true \\\"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\\\"\\n                   (count results) results))\\n\\nPrints via *print-fn*:\\n There are 3 results: 46, 38, 22\\n\\nDetailed documentation on format control strings is available in the \\\"Common Lisp the\\nLanguage, 2nd edition\\\", Chapter 22 (available online at:\\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\\nand in the Common Lisp HyperSpec at\\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n {:see-also\n  [[\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000\"\n    \"Common Lisp the Language\"]\n   [\"http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n    \"Common Lisp HyperSpec\"]]}\n [writer format-in & args]\n (let\n  [compiled-format\n   (if (string? format-in) (compile-format format-in) format-in)\n   navigator\n   (init-navigator args)]\n  (execute-format writer compiled-format navigator)))\n"} {:sym *print-miser-width*, :meta {:doc "The column at which to enter miser style. Depending on the dispatch table,\nmiser style add newlines in more places to try to keep lines short allowing for further\nlevels of nesting."}, :source "(def *print-miser-width* 40)\n"} {:sym write, :meta {:doc "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n", :arglists ([object & kw-args])}, :source "(defn\n write\n \"Write an object subject to the current bindings of the printer control variables.\\nUse the kw-args argument to override individual variables for this call (and any\\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\\n\\nThe following keyword arguments can be passed with values:\\n  Keyword              Meaning                              Default value\\n  :stream              Writer for output or nil             true (indicates *out*)\\n  :base                Base to use for writing rationals    Current value of *print-base*\\n  :circle*             If true, mark circular structures    Current value of *print-circle*\\n  :length              Maximum elements to show in sublists Current value of *print-length*\\n  :level               Maximum depth                        Current value of *print-level*\\n  :lines*              Maximum lines of output              Current value of *print-lines*\\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\\n  :readably*           If true, print readably              Current value of *print-readably*\\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\\n\\n  * = not yet supported\\n\"\n [object & kw-args]\n (let\n  [options (merge {:stream true} (apply hash-map kw-args))]\n  (binding\n   [cljs.pprint/*print-base*\n    (:base options cljs.pprint/*print-base*)\n    cljs.pprint/*print-circle*\n    (:circle options cljs.pprint/*print-circle*)\n    cljs.core/*print-length*\n    (:length options cljs.core/*print-length*)\n    cljs.core/*print-level*\n    (:level options cljs.core/*print-level*)\n    cljs.pprint/*print-lines*\n    (:lines options cljs.pprint/*print-lines*)\n    cljs.pprint/*print-miser-width*\n    (:miser-width options cljs.pprint/*print-miser-width*)\n    cljs.pprint/*print-pprint-dispatch*\n    (:dispatch options cljs.pprint/*print-pprint-dispatch*)\n    cljs.pprint/*print-pretty*\n    (:pretty options cljs.pprint/*print-pretty*)\n    cljs.pprint/*print-radix*\n    (:radix options cljs.pprint/*print-radix*)\n    cljs.core/*print-readably*\n    (:readably options cljs.core/*print-readably*)\n    cljs.pprint/*print-right-margin*\n    (:right-margin options cljs.pprint/*print-right-margin*)\n    cljs.pprint/*print-suppress-namespaces*\n    (:suppress-namespaces\n     options\n     cljs.pprint/*print-suppress-namespaces*)]\n   (binding\n    []\n    (let\n     [sb\n      (StringBuffer.)\n      optval\n      (if (contains? options :stream) (:stream options) true)\n      base-writer\n      (if\n       (or (true? optval) (nil? optval))\n       (StringBufferWriter. sb)\n       optval)]\n     (if\n      *print-pretty*\n      (with-pretty-writer base-writer (write-out object))\n      (binding [*out* base-writer] (pr object)))\n     (if (true? optval) (string-print (str sb)))\n     (if (nil? optval) (str sb)))))))\n"} {:sym -ppflush, :meta {:doc nil, :arglists ([pp])}, :protocol IPrettyFlush} {:sym *print-right-margin*, :meta {:doc "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all\nnon-mandatory newlines."}, :source "(def *print-right-margin* 72)\n"} {:sym write-out, :meta {:doc "Write an object to *out* subject to the current bindings of the printer control\nvariables. Use the kw-args argument to override individual variables for this call (and\nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that\nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. ", :arglists ([object])}, :source "(defn\n write-out\n \"Write an object to *out* subject to the current bindings of the printer control\\nvariables. Use the kw-args argument to override individual variables for this call (and\\nany recursive calls).\\n\\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\\nof the caller.\\n\\nThis method is primarily intended for use by pretty print dispatch functions that\\nalready know that the pretty printer will have set up their environment appropriately.\\nNormal library clients should use the standard \\\"write\\\" interface. \"\n [object]\n (let\n  [length-reached\n   (and\n    *current-length*\n    *print-length*\n    (>= *current-length* *print-length*))]\n  (if-not\n   *print-pretty*\n   (pr object)\n   (if\n    length-reached\n    (-write *out* \"...\")\n    (do\n     (if\n      *current-length*\n      (set! *current-length* (inc *current-length*)))\n     (*print-pprint-dispatch* object))))\n  length-reached))\n"} {:sym *print-base*, :meta {:doc "The base to use for printing integers and rationals."}, :source "(def *print-base* 10)\n"}), cljs.repl ({:sym print-doc, :meta {:doc nil, :arglists ([{n :ns, nm :name, :as m}])}, :source "(defn\n print-doc\n [{n :ns, nm :name, :as m}]\n (println \"-------------------------\")\n (println (str (when-let [ns (:ns m)] (str ns \"/\")) (:name m)))\n (when (:protocol m) (println \"Protocol\"))\n (cond\n  (:forms m)\n  (doseq [f (:forms m)] (println \"  \" f))\n  (:arglists m)\n  (let\n   [arglists (:arglists m)]\n   (if\n    (or (:macro m) (:repl-special-function m))\n    (prn arglists)\n    (prn\n     (if (= 'quote (first arglists)) (second arglists) arglists)))))\n (if\n  (:special-form m)\n  (do\n   (println \"Special Form\")\n   (println \" \" (:doc m))\n   (if\n    (contains? m :url)\n    (when\n     (:url m)\n     (println (str \"\\n  Please see http://clojure.org/\" (:url m))))\n    (println\n     (str\n      \"\\n  Please see http://clojure.org/special_forms#\"\n      (:name m)))))\n  (do\n   (when (:macro m) (println \"Macro\"))\n   (when (:repl-special-function m) (println \"REPL Special Function\"))\n   (println \" \" (:doc m))\n   (when\n    (:protocol m)\n    (doseq\n     [[name {:keys [doc arglists]}] (:methods m)]\n     (println)\n     (println \" \" name)\n     (println \" \" arglists)\n     (when doc (println \" \" doc))))\n   (when\n    n\n    (when-let\n     [fnspec (spec/get-spec (symbol (str (ns-name n)) (name nm)))]\n     (print \"Spec\")\n     (doseq\n      [role [:args :ret :fn]]\n      (when-let\n       [spec (get fnspec role)]\n       (print (str \"\\n \" (name role) \":\") (spec/describe spec)))))))))\n"}), cljs.spec.alpha ({:sym form, :meta {:doc "returns the spec as data", :arglists ([spec])}, :source "(defn form \"returns the spec as data\" [spec] (describe* (specize spec)))\n"} {:sym nilable-impl, :meta {:doc "Do not call this directly, use 'nilable'", :arglists ([form pred gfn])}, :source "(defn\n nilable-impl\n \"Do not call this directly, use 'nilable'\"\n [form pred gfn]\n (let\n  [spec (specize pred form)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (if (nil? x) nil (conform* spec x)))\n   (unform* [_ x] (if (nil? x) nil (unform* spec x)))\n   (explain*\n    [_ path via in x]\n    (when-not\n     (c/or (pvalid? spec x) (nil? x))\n     (conj\n      (explain-1 form pred (conj path :clojure.core/pred) via in x)\n      {:path (conj path :clojure.core/nil),\n       :pred 'nil?,\n       :val x,\n       :via via,\n       :in in})))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (gen/frequency\n      [[1 (gen/delay (gen/return nil))]\n       [9\n        (gen/delay\n         (gensub\n          pred\n          overrides\n          (conj path :clojure.core/pred)\n          rmap\n          form))]])))\n   (with-gen* [_ gfn] (nilable-impl form pred gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/nilable)\n       (clojure.core/list (s/mres form)))))))))\n"} {:sym *recursion-limit*, :meta {}, :source "(def\n *recursion-limit*\n \"A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\\n  can be recursed through during generation. After this a\\n  non-recursive branch will be chosen.\"\n 4)\n"} {:sym *coll-error-limit*, :meta {}, :source "(def\n *coll-error-limit*\n \"The number of errors reported by explain in a collection spec'ed with 'every'\"\n 20)\n"} {:sym explain-printer, :meta {:doc "Default printer for explain-data. nil indicates a successful validation.", :arglists ([ed])}, :source "(defn\n explain-printer\n \"Default printer for explain-data. nil indicates a successful validation.\"\n [ed]\n (if\n  ed\n  (let\n   [problems\n    (sort-by\n     (fn* [p1__19490#] (- (count (:path p1__19490#))))\n     (:clojure.core/problems ed))]\n   (print\n    (with-out-str\n     (doseq\n      [{:keys [path pred val reason via in], :as prob} problems]\n      (when-not (empty? in) (print \"In:\" (pr-str in) \"\"))\n      (print \"val: \")\n      (pr val)\n      (print \" fails\")\n      (when-not (empty? via) (print \" spec:\" (pr-str (last via))))\n      (when-not (empty? path) (print \" at:\" (pr-str path)))\n      (print \" predicate: \")\n      (pr (abbrev pred))\n      (when reason (print \", \" reason))\n      (doseq\n       [[k v] prob]\n       (when-not\n        (#{:path :pred :via :val :reason :in} k)\n        (print \"\\n\\t\" (pr-str k) \" \")\n        (pr v)))\n      (newline))\n     (doseq\n      [[k v] ed]\n      (when-not\n       (#{:clojure.core/problems} k)\n       (print (pr-str k) \" \")\n       (pr v)\n       (newline))))))\n  (println \"Success!\")))\n"} {:sym Specize, :meta {:doc nil}, :methods (specize*)} {:sym alt-impl, :meta {:doc "Do not call this directly, use 'alt'", :arglists ([ks ps forms])}, :source "(defn\n alt-impl\n \"Do not call this directly, use 'alt'\"\n [ks ps forms]\n (assoc (alt* ps ks forms) :id (random-uuid)))\n"} {:sym def-impl, :meta {:doc "Do not call this directly, use 'def'", :arglists ([k form spec])}, :source "(defn\n def-impl\n \"Do not call this directly, use 'def'\"\n [k form spec]\n (assert\n  (c/and (ident? k) (namespace k))\n  \"k must be namespaced keyword or resolveable symbol\")\n (let\n  [spec\n   (if\n    (c/or (spec? spec) (regex? spec) (get @registry-ref spec))\n    spec\n    (spec-impl form spec nil nil))]\n  (swap! registry-ref assoc k (with-name spec k))\n  k))\n"} {:sym *explain-out*, :meta {}, :source "(def *explain-out* explain-printer)\n"} {:sym regex-spec-impl, :meta {:doc "Do not call this directly, use 'spec' with a regex op argument", :arglists ([re gfn])}, :source "(defn\n regex-spec-impl\n \"Do not call this directly, use 'spec' with a regex op argument\"\n [re gfn]\n (reify\n  Specize\n  (specize* [s] s)\n  (specize* [s _] s)\n  Spec\n  (conform*\n   [_ x]\n   (if\n    (c/or (nil? x) (coll? x))\n    (re-conform re (seq x))\n    :clojure.core/invalid))\n  (unform* [_ x] (op-unform re x))\n  (explain*\n   [_ path via in x]\n   (if\n    (c/or (nil? x) (coll? x))\n    (re-explain path via in re (seq x))\n    [{:path path, :pred (op-describe re), :val x, :via via, :in in}]))\n  (gen*\n   [_ overrides path rmap]\n   (if gfn (gfn) (re-gen re overrides path rmap (op-describe re))))\n  (with-gen* [_ gfn] (regex-spec-impl re gfn))\n  (describe* [_] (op-describe re))))\n"} {:sym merge-spec-impl, :meta {:doc "Do not call this directly, use 'merge'", :arglists ([forms preds gfn])}, :source "(defn\n merge-spec-impl\n \"Do not call this directly, use 'merge'\"\n [forms preds gfn]\n (reify\n  Specize\n  (specize* [s] s)\n  (specize* [s _] s)\n  Spec\n  (conform*\n   [_ x]\n   (let\n    [ms\n     (map\n      (fn* [p1__19502# p2__19503#] (dt p1__19502# x p2__19503#))\n      preds\n      forms)]\n    (if (some invalid? ms) :clojure.core/invalid (apply c/merge ms))))\n  (unform*\n   [_ x]\n   (apply\n    c/merge\n    (map (fn* [p1__19504#] (unform p1__19504# x)) (reverse preds))))\n  (explain*\n   [_ path via in x]\n   (apply\n    concat\n    (map\n     (fn*\n      [p1__19505# p2__19506#]\n      (explain-1 p1__19505# p2__19506# path via in x))\n     forms\n     preds)))\n  (gen*\n   [_ overrides path rmap]\n   (if\n    gfn\n    (gfn)\n    (gen/fmap\n     (fn* [p1__19507#] (apply c/merge p1__19507#))\n     (apply\n      gen/tuple\n      (map\n       (fn*\n        [p1__19508# p2__19509#]\n        (gensub p1__19508# overrides path rmap p2__19509#))\n       preds\n       forms)))))\n  (with-gen* [_ gfn] (merge-spec-impl forms preds gfn))\n  (describe*\n   [_]\n   (clojure.core/sequence\n    (clojure.core/seq\n     (clojure.core/concat\n      (clojure.core/list 'clojure.core/merge)\n      forms))))))\n"} {:sym explain-data*, :meta {:doc nil, :arglists ([spec path via in x])}, :source "(defn\n explain-data*\n [spec path via in x]\n (when-let\n  [probs (explain* (specize spec) path via in x)]\n  (when-not\n   (empty? probs)\n   {:clojure.core/problems probs,\n    :clojure.core/spec spec,\n    :clojure.core/value x})))\n"} {:sym MAX_INT, :meta {}, :source "(def MAX_INT 9007199254740991)\n"} {:sym check-asserts, :meta {:doc "Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\nDefaults to false.", :arglists ([flag])}, :source "(defn\n check-asserts\n \"Enable or disable spec asserts that have been compiled\\nwith '*compile-asserts*' true.  See 'assert'.\\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\\nDefaults to false.\"\n [flag]\n (set! *runtime-asserts* flag))\n"} {:sym assert*, :meta {:doc "Do not call this directly, use 'assert'.", :arglists ([spec x])}, :source "(defn\n assert*\n \"Do not call this directly, use 'assert'.\"\n [spec x]\n (if\n  (valid? spec x)\n  x\n  (let\n   [ed\n    (c/merge\n     (assoc\n      (explain-data* spec [] [] [] x)\n      :clojure.core/failure\n      :assertion-failed))]\n   (throw\n    (js/Error.\n     (str\n      \"Spec assertion failed\\n\"\n      (with-out-str (explain-out ed))))))))\n"} {:sym inst-in-range?, :meta {:doc "Return true if inst at or after start and before end", :arglists ([start end inst])}, :source "(defn\n inst-in-range?\n \"Return true if inst at or after start and before end\"\n [start end inst]\n (c/and\n  (inst? inst)\n  (let\n   [t (inst-ms inst)]\n   (c/and (<= (inst-ms start) t) (< t (inst-ms end))))))\n"} {:sym and-spec-impl, :meta {:doc "Do not call this directly, use 'and'", :arglists ([forms preds gfn])}, :source "(defn\n and-spec-impl\n \"Do not call this directly, use 'and'\"\n [forms preds gfn]\n (let\n  [specs\n   (delay (mapv specize preds forms))\n   cform\n   (case\n    (count preds)\n    2\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       :clojure.core/invalid\n       (conform* (specs 1) ret))))\n    3\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       :clojure.core/invalid\n       (let\n        [ret (conform* (specs 1) ret)]\n        (if\n         (invalid? ret)\n         :clojure.core/invalid\n         (conform* (specs 2) ret))))))\n    (fn\n     [x]\n     (let\n      [specs @specs]\n      (loop\n       [ret x i 0]\n       (if\n        (< i (count specs))\n        (let\n         [nret (conform* (specs i) ret)]\n         (if\n          (invalid? nret)\n          :clojure.core/invalid\n          (recur nret (inc i))))\n        ret)))))]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (cform x))\n   (unform*\n    [_ x]\n    (reduce\n     (fn* [p1__19501# p2__19500#] (unform p2__19500# p1__19501#))\n     x\n     (reverse preds)))\n   (explain*\n    [_ path via in x]\n    (explain-pred-list forms preds path via in x))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (gensub (first preds) overrides path rmap (first forms))))\n   (with-gen* [_ gfn] (and-spec-impl forms preds gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/and)\n       forms)))))))\n"} {:sym describe*, :meta {:doc nil, :arglists ([spec])}, :protocol Spec} {:sym map-spec-impl, :meta {:doc "Do not call this directly, use 'spec' with a map argument", :arglists ([{:keys [req-un opt-un keys-pred pred-exprs opt-keys req-specs req req-keys opt-specs pred-forms opt gfn], :as argm}])}, :source "(defn\n map-spec-impl\n \"Do not call this directly, use 'spec' with a map argument\"\n [{:keys\n   [req-un\n    opt-un\n    keys-pred\n    pred-exprs\n    opt-keys\n    req-specs\n    req\n    req-keys\n    opt-specs\n    pred-forms\n    opt\n    gfn],\n   :as argm}]\n (let\n  [k->s\n   (zipmap (concat req-keys opt-keys) (concat req-specs opt-specs))\n   keys->specnames\n   (fn* [p1__19492#] (c/or (k->s p1__19492#) p1__19492#))\n   id\n   (random-uuid)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ m]\n    (if\n     (keys-pred m)\n     (let\n      [reg (registry)]\n      (loop\n       [ret m [[k v] & ks :as keys] m]\n       (if\n        keys\n        (let\n         [sname (keys->specnames k)]\n         (if-let\n          [s (get reg sname)]\n          (let\n           [cv (conform s v)]\n           (if\n            (invalid? cv)\n            :clojure.core/invalid\n            (recur (if (identical? cv v) ret (assoc ret k cv)) ks)))\n          (recur ret ks)))\n        ret)))\n     :clojure.core/invalid))\n   (unform*\n    [_ m]\n    (let\n     [reg (registry)]\n     (loop\n      [ret m [k & ks :as keys] (c/keys m)]\n      (if\n       keys\n       (if\n        (contains? reg (keys->specnames k))\n        (let\n         [cv (get m k) v (unform (keys->specnames k) cv)]\n         (recur (if (identical? cv v) ret (assoc ret k v)) ks))\n        (recur ret ks))\n       ret))))\n   (explain*\n    [_ path via in x]\n    (if-not\n     (map? x)\n     [{:path path, :pred 'map?, :val x, :via via, :in in}]\n     (let\n      [reg (registry)]\n      (apply\n       concat\n       (when-let\n        [probs\n         (->>\n          (map\n           (fn [pred form] (when-not (pred x) form))\n           pred-exprs\n           pred-forms)\n          (keep identity)\n          seq)]\n        (map\n         (fn*\n          [p1__19493#]\n          (identity\n           {:path path, :pred p1__19493#, :val x, :via via, :in in}))\n         probs))\n       (map\n        (fn\n         [[k v]]\n         (when-not\n          (c/or\n           (not (contains? reg (keys->specnames k)))\n           (pvalid? (keys->specnames k) v k))\n          (explain-1\n           (keys->specnames k)\n           (keys->specnames k)\n           (conj path k)\n           via\n           (conj in k)\n           v)))\n        (seq x))))))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (let\n      [rmap\n       (inck rmap id)\n       gen\n       (fn [k s] (gensub s overrides (conj path k) rmap k))\n       ogen\n       (fn\n        [k s]\n        (when-not\n         (recur-limit? rmap id path k)\n         [k (gen/delay (gensub s overrides (conj path k) rmap k))]))\n       req-gens\n       (map gen req-keys req-specs)\n       opt-gens\n       (remove nil? (map ogen opt-keys opt-specs))]\n      (when\n       (every? identity (concat req-gens opt-gens))\n       (let\n        [reqs (zipmap req-keys req-gens) opts (into {} opt-gens)]\n        (gen/bind\n         (gen/choose 0 (count opts))\n         (fn*\n          [p1__19494#]\n          (let\n           [args\n            (concat (seq reqs) (when (seq opts) (shuffle (seq opts))))]\n           (->>\n            args\n            (take (c/+ p1__19494# (count reqs)))\n            (apply concat)\n            (apply gen/hash-map))))))))))\n   (with-gen* [_ gfn] (map-spec-impl (assoc argm :gfn gfn)))\n   (describe*\n    [_]\n    (cons\n     'clojure.core/keys\n     (cond->\n      []\n      req\n      (conj :req req)\n      opt\n      (conj :opt opt)\n      req-un\n      (conj :req-un req-un)\n      opt-un\n      (conj :opt-un opt-un)))))))\n"} {:sym explain, :meta {:doc "Given a spec and a value that fails to conform, prints an explanation to *out*.", :arglists ([spec x])}, :source "(defn\n explain\n \"Given a spec and a value that fails to conform, prints an explanation to *out*.\"\n [spec x]\n (explain-out (explain-data spec x)))\n"} {:sym with-gen*, :meta {:doc nil, :arglists ([spec gfn])}, :protocol Spec} {:sym or-spec-impl, :meta {:doc "Do not call this directly, use 'or'", :arglists ([keys forms preds gfn])}, :source "(defn\n or-spec-impl\n \"Do not call this directly, use 'or'\"\n [keys forms preds gfn]\n (let\n  [id\n   (random-uuid)\n   kps\n   (zipmap keys preds)\n   specs\n   (delay (mapv specize preds forms))\n   cform\n   (case\n    (count preds)\n    2\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       (let\n        [ret (conform* (specs 1) x)]\n        (if\n         (invalid? ret)\n         :clojure.core/invalid\n         (tagged-ret [(keys 1) ret])))\n       (tagged-ret [(keys 0) ret]))))\n    3\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       (let\n        [ret (conform* (specs 1) x)]\n        (if\n         (invalid? ret)\n         (let\n          [ret (conform* (specs 2) x)]\n          (if\n           (invalid? ret)\n           :clojure.core/invalid\n           (tagged-ret [(keys 2) ret])))\n         (tagged-ret [(keys 1) ret])))\n       (tagged-ret [(keys 0) ret]))))\n    (fn\n     [x]\n     (let\n      [specs @specs]\n      (loop\n       [i 0]\n       (if\n        (< i (count specs))\n        (let\n         [spec (specs i)]\n         (let\n          [ret (conform* spec x)]\n          (if\n           (invalid? ret)\n           (recur (inc i))\n           (tagged-ret [(keys i) ret]))))\n        :clojure.core/invalid)))))]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (cform x))\n   (unform* [_ [k x]] (unform (kps k) x))\n   (explain*\n    [this path via in x]\n    (when-not\n     (pvalid? this x)\n     (apply\n      concat\n      (map\n       (fn\n        [k form pred]\n        (when-not\n         (pvalid? pred x)\n         (explain-1 form pred (conj path k) via in x)))\n       keys\n       forms\n       preds))))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (let\n      [gen\n       (fn\n        [k p f]\n        (let\n         [rmap (inck rmap id)]\n         (when-not\n          (recur-limit? rmap id path k)\n          (gen/delay (gensub p overrides (conj path k) rmap f)))))\n       gs\n       (remove nil? (map gen keys preds forms))]\n      (when-not (empty? gs) (gen/one-of gs)))))\n   (with-gen* [_ gfn] (or-spec-impl keys forms preds gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/or)\n       (mapcat vector keys forms))))))))\n"} {:sym *fspec-iterations*, :meta {}, :source "(def\n *fspec-iterations*\n \"The number of times an anonymous fn specified by fspec will be (generatively) tested during conform\"\n 21)\n"} {:sym Spec, :meta {:doc nil}, :methods (conform* describe* explain* gen* unform* with-gen*)} {:sym unform, :meta {:doc "Given a spec and a value created by or compliant with a call to\n  'conform' with the same spec, returns a value with all conform\n   destructuring undone.", :arglists ([spec x])}, :source "(defn\n unform\n \"Given a spec and a value created by or compliant with a call to\\n  'conform' with the same spec, returns a value with all conform\\n   destructuring undone.\"\n [spec x]\n (unform* (specize spec) x))\n"} {:sym valid?, :meta {:doc "Helper function that returns true when x is valid for spec.", :arglists [[spec x] [spec x form]]}, :source "(defn\n valid?\n \"Helper function that returns true when x is valid for spec.\"\n ([spec x]\n  (let [spec (specize spec)] (not (invalid? (conform* spec x)))))\n ([spec x form]\n  (let [spec (specize spec form)] (not (invalid? (conform* spec x))))))\n"} {:sym gen, :meta {:doc "Given a spec, returns the generator for it, or throws if none can\n  be constructed. Optionally an overrides map can be provided which\n  should map spec names or paths (vectors of keywords) to no-arg\n  generator-creating fns. These will be used instead of the generators at those\n  names/paths. Note that parent generator (in the spec or overrides\n  map) will supersede those of any subtrees. A generator for a regex\n  op must always return a sequential collection (i.e. a generator for\n  s/? should return either an empty sequence/vector or a\n  sequence/vector with one item in it)", :arglists [[spec] [spec overrides]]}, :source "(defn\n gen\n \"Given a spec, returns the generator for it, or throws if none can\\n  be constructed. Optionally an overrides map can be provided which\\n  should map spec names or paths (vectors of keywords) to no-arg\\n  generator-creating fns. These will be used instead of the generators at those\\n  names/paths. Note that parent generator (in the spec or overrides\\n  map) will supersede those of any subtrees. A generator for a regex\\n  op must always return a sequential collection (i.e. a generator for\\n  s/? should return either an empty sequence/vector or a\\n  sequence/vector with one item in it)\"\n ([spec] (gen spec nil))\n ([spec overrides]\n  (gensub\n   spec\n   overrides\n   []\n   {:clojure.core/recursion-limit *recursion-limit*}\n   spec)))\n"} {:sym nonconforming, :meta {:doc "takes a spec and returns a spec that has the same properties except\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.", :arglists ([spec])}, :source "(defn\n nonconforming\n \"takes a spec and returns a spec that has the same properties except\\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.\"\n [spec]\n (let\n  [spec (specize spec)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ x]\n    (let\n     [ret (conform* spec x)]\n     (if (invalid? ret) :clojure.core/invalid x)))\n   (unform* [_ x] (unform* spec x))\n   (explain* [_ path via in x] (explain* spec path via in x))\n   (gen* [_ overrides path rmap] (gen* spec overrides path rmap))\n   (with-gen* [_ gfn] (nonconforming (with-gen* spec gfn)))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/nonconforming)\n       (clojure.core/list (describe* spec)))))))))\n"} {:sym unform*, :meta {:doc nil, :arglists ([spec y])}, :protocol Spec} {:sym abbrev, :meta {:doc nil, :arglists ([form])}, :source "(defn\n abbrev\n [form]\n (cond\n  (seq? form)\n  (walk/postwalk\n   (fn\n    [form]\n    (cond\n     (c/and (symbol? form) (namespace form))\n     (-> form name symbol)\n     (c/and (seq? form) (= 'fn (first form)) (= '[%] (second form)))\n     (last form)\n     :else\n     form))\n   form)\n  (c/and (symbol? form) (namespace form))\n  (-> form name symbol)\n  :else\n  form))\n"} {:sym regex?, :meta {:doc "returns x if x is a (cljs.spec.alpha) regex op, else logical false", :arglists ([x])}, :source "(defn\n regex?\n \"returns x if x is a (cljs.spec.alpha) regex op, else logical false\"\n [x]\n (c/and (:clojure.core/op x) x))\n"} {:sym int-in-range?, :meta {:doc "Return true if start <= val, val < end and val is a fixed\n  precision integer.", :arglists ([start end val])}, :source "(defn\n int-in-range?\n \"Return true if start <= val, val < end and val is a fixed\\n  precision integer.\"\n [start end val]\n (cond\n  (integer? val)\n  (c/and (<= start val) (< val end))\n  (instance? goog.math.Long val)\n  (c/and (.lessThanOrEqual start val) (.lessThan val end))\n  (instance? goog.math.Integer val)\n  (c/and (.lessThanOrEqual start val) (.lessThan val end))\n  :else\n  false))\n"} {:sym spec?, :meta {:doc "returns x if x is a spec object, else logical false", :arglists ([x])}, :source "(defn\n spec?\n \"returns x if x is a spec object, else logical false\"\n [x]\n (when (implements? Spec x) x))\n"} {:sym registry, :meta {:doc "returns the registry map, prefer 'get-spec' to lookup a spec by name", :arglists ([])}, :source "(defn\n registry\n \"returns the registry map, prefer 'get-spec' to lookup a spec by name\"\n []\n @registry-ref)\n"} {:sym rep+impl, :meta {:doc "Do not call this directly, use '+'", :arglists ([form p])}, :source "(defn\n rep+impl\n \"Do not call this directly, use '+'\"\n [form p]\n (pcat*\n  {:ps [p (rep* p p [] true form)],\n   :forms\n   (clojure.core/vec\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list form)\n       (clojure.core/list\n        (clojure.core/sequence\n         (clojure.core/seq\n          (clojure.core/concat\n           (clojure.core/list 'clojure.core/*)\n           (clojure.core/list form))))))))),\n   :ret [],\n   :rep+ form}))\n"} {:sym exercise, :meta {:doc "generates a number (default 10) of values compatible with spec and maps conform over them,\n  returning a sequence of [val conformed-val] tuples. Optionally takes\n  a generator overrides map as per gen", :arglists [[spec] [spec n] [spec n overrides]]}, :source "(defn\n exercise\n \"generates a number (default 10) of values compatible with spec and maps conform over them,\\n  returning a sequence of [val conformed-val] tuples. Optionally takes\\n  a generator overrides map as per gen\"\n ([spec] (exercise spec 10))\n ([spec n] (exercise spec n nil))\n ([spec n overrides]\n  (map\n   (fn* [p1__19525#] (vector p1__19525# (conform spec p1__19525#)))\n   (gen/sample (gen spec overrides) n))))\n"} {:sym explain-data, :meta {:doc "Given a spec and a value x which ought to conform, returns nil if x\n  conforms, else a map with at least the key ::problems whose value is\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\n  keys describing the predicate and the value that failed at that\n  path.", :arglists ([spec x])}, :source "(defn\n explain-data\n \"Given a spec and a value x which ought to conform, returns nil if x\\n  conforms, else a map with at least the key ::problems whose value is\\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\\n  keys describing the predicate and the value that failed at that\\n  path.\"\n [spec x]\n (explain-data*\n  spec\n  []\n  (if-let [name (spec-name spec)] [name] [])\n  []\n  x))\n"} {:sym tuple-impl, :meta {:doc "Do not call this directly, use 'tuple'", :arglists [[forms preds] [forms preds gfn]]}, :source "(defn\n tuple-impl\n \"Do not call this directly, use 'tuple'\"\n ([forms preds] (tuple-impl forms preds nil))\n ([forms preds gfn]\n  (let\n   [specs (delay (mapv specize preds forms)) cnt (count preds)]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [specs @specs]\n      (if-not\n       (c/and (vector? x) (= (count x) cnt))\n       :clojure.core/invalid\n       (loop\n        [ret x i 0]\n        (if\n         (= i cnt)\n         ret\n         (let\n          [v (x i) cv (conform* (specs i) v)]\n          (if\n           (invalid? cv)\n           :clojure.core/invalid\n           (recur\n            (if (identical? cv v) ret (assoc ret i cv))\n            (inc i)))))))))\n    (unform*\n     [_ x]\n     (assert (c/and (vector? x) (= (count x) (count preds))))\n     (loop\n      [ret x i 0]\n      (if\n       (= i (count x))\n       ret\n       (let\n        [cv (x i) v (unform (preds i) cv)]\n        (recur (if (identical? cv v) ret (assoc ret i v)) (inc i))))))\n    (explain*\n     [_ path via in x]\n     (cond\n      (not (vector? x))\n      [{:path path, :pred 'vector?, :val x, :via via, :in in}]\n      (not= (count x) (count preds))\n      [{:path path,\n        :pred\n        (clojure.core/sequence\n         (clojure.core/seq\n          (clojure.core/concat\n           (clojure.core/list 'clojure.core/=)\n           (clojure.core/list\n            (clojure.core/sequence\n             (clojure.core/seq\n              (clojure.core/concat\n               (clojure.core/list 'clojure.core/count)\n               (clojure.core/list '%)))))\n           (clojure.core/list (count preds))))),\n        :val x,\n        :via via,\n        :in in}]\n      :else\n      (apply\n       concat\n       (map\n        (fn\n         [i form pred]\n         (let\n          [v (x i)]\n          (when-not\n           (pvalid? pred v)\n           (explain-1 form pred (conj path i) via (conj in i) v))))\n        (range (count preds))\n        forms\n        preds))))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [gen\n        (fn [i p f] (gensub p overrides (conj path i) rmap f))\n        gs\n        (map gen (range (count preds)) preds forms)]\n       (when (every? identity gs) (apply gen/tuple gs)))))\n    (with-gen* [_ gfn] (tuple-impl forms preds gfn))\n    (describe*\n     [_]\n     (clojure.core/sequence\n      (clojure.core/seq\n       (clojure.core/concat\n        (clojure.core/list 'clojure.core/tuple)\n        forms))))))))\n"} {:sym multi-spec-impl, :meta {:doc "Do not call this directly, use 'multi-spec'", :arglists [[form mmvar retag] [form mmvar retag gfn]]}, :source "(defn\n multi-spec-impl\n \"Do not call this directly, use 'multi-spec'\"\n ([form mmvar retag] (multi-spec-impl form mmvar retag nil))\n ([form mmvar retag gfn]\n  (let\n   [id\n    (random-uuid)\n    predx\n    (fn*\n     [p1__19495#]\n     (let\n      [mm @mmvar]\n      (c/and\n       (-get-method mm ((-dispatch-fn mm) p1__19495#))\n       (mm p1__19495#))))\n    dval\n    (fn* [p1__19496#] ((-dispatch-fn @mmvar) p1__19496#))\n    tag\n    (if\n     (keyword? retag)\n     (fn* [p1__19497# p2__19498#] (assoc p1__19497# retag p2__19498#))\n     retag)]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (if-let [pred (predx x)] (dt pred x form) :clojure.core/invalid))\n    (unform*\n     [_ x]\n     (if-let\n      [pred (predx x)]\n      (unform pred x)\n      (throw\n       (js/Error.\n        (str\n         \"No method of: \"\n         form\n         \" for dispatch value: \"\n         (dval x))))))\n    (explain*\n     [_ path via in x]\n     (let\n      [dv (dval x) path (conj path dv)]\n      (if-let\n       [pred (predx x)]\n       (explain-1 form pred path via in x)\n       [{:path path,\n         :pred form,\n         :val x,\n         :reason \"no method\",\n         :via via,\n         :in in}])))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [gen\n        (fn\n         [[k f]]\n         (let\n          [p (f nil)]\n          (let\n           [rmap (inck rmap id)]\n           (when-not\n            (recur-limit? rmap id path k)\n            (gen/delay\n             (gen/fmap\n              (fn* [p1__19499#] (tag p1__19499# k))\n              (gensub\n               p\n               overrides\n               (conj path k)\n               rmap\n               (list 'method form k))))))))\n        gs\n        (->>\n         (methods @mmvar)\n         (remove (fn [[k]] (invalid? k)))\n         (map gen)\n         (remove nil?))]\n       (when (every? identity gs) (gen/one-of gs)))))\n    (with-gen* [_ gfn] (multi-spec-impl form mmvar retag gfn))\n    (describe*\n     [_]\n     (clojure.core/sequence\n      (clojure.core/seq\n       (clojure.core/concat\n        (clojure.core/list 'clojure.core/multi-spec)\n        (clojure.core/list form)\n        (clojure.core/list retag)))))))))\n"} {:sym conform, :meta {:doc "Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\n  not match spec, else the (possibly destructured) value.", :arglists ([spec x])}, :source "(defn\n conform\n \"Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\\n  not match spec, else the (possibly destructured) value.\"\n [spec x]\n (conform* (specize spec) x))\n"} {:sym gen*, :meta {:doc nil, :arglists ([spec overrides path rmap])}, :protocol Spec} {:sym fspec-impl, :meta {:doc "Do not call this directly, use 'fspec'", :arglists ([argspec aform retspec rform fnspec fform gfn])}, :source "(defn\n fspec-impl\n \"Do not call this directly, use 'fspec'\"\n [argspec aform retspec rform fnspec fform gfn]\n (let\n  [specs {:args argspec, :ret retspec, :fn fnspec}]\n  (reify\n   ILookup\n   (-lookup [this k] (get specs k))\n   (-lookup [_ k not-found] (get specs k not-found))\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ f]\n    (if\n     (ifn? f)\n     (if\n      (identical? f (validate-fn f specs *fspec-iterations*))\n      f\n      :clojure.core/invalid)\n     :clojure.core/invalid))\n   (unform* [_ f] f)\n   (explain*\n    [_ path via in f]\n    (if\n     (ifn? f)\n     (let\n      [args (validate-fn f specs 100)]\n      (if\n       (identical? f args)\n       nil\n       (let\n        [ret (try (apply f args) (catch js/Error t t))]\n        (if\n         (instance? js/Error ret)\n         [{:path path,\n           :pred '(apply fn),\n           :val args,\n           :reason (.-message ret),\n           :via via,\n           :in in}]\n         (let\n          [cret (dt retspec ret rform)]\n          (if\n           (invalid? cret)\n           (explain-1 rform retspec (conj path :ret) via in ret)\n           (when\n            fnspec\n            (let\n             [cargs (conform argspec args)]\n             (explain-1\n              fform\n              fnspec\n              (conj path :fn)\n              via\n              in\n              {:args cargs, :ret cret})))))))))\n     [{:path path, :pred 'ifn?, :val f, :via via, :in in}]))\n   (gen*\n    [_ overrides _ _]\n    (if\n     gfn\n     (gfn)\n     (gen/return\n      (fn\n       [& args]\n       (assert\n        (pvalid? argspec args)\n        (with-out-str (explain argspec args)))\n       (gen/generate (gen retspec overrides))))))\n   (with-gen*\n    [_ gfn]\n    (fspec-impl argspec aform retspec rform fnspec fform gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/fspec)\n       (clojure.core/list :args)\n       (clojure.core/list aform)\n       (clojure.core/list :ret)\n       (clojure.core/list rform)\n       (clojure.core/list :fn)\n       (clojure.core/list fform))))))))\n"} {:sym *coll-check-limit*, :meta {}, :source "(def\n *coll-check-limit*\n \"The number of items validated in a collection spec'ed with 'every'\"\n 101)\n"} {:sym get-spec, :meta {:doc "Returns spec registered for keyword/symbol/var k, or nil.", :arglists ([k])}, :source "(defn\n get-spec\n \"Returns spec registered for keyword/symbol/var k, or nil.\"\n [k]\n (get (registry) (if (keyword? k) k (->sym k))))\n"} {:sym every-impl, :meta {:doc "Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'", :arglists [[form pred opts] [form pred {gen-into :into, describe-form :clojure.core/describe, :keys [kind :clojure.core/kind-form count max-count min-count distinct gen-max :clojure.core/kfn :clojure.core/cpred conform-keys :clojure.core/conform-all], :or {gen-max 20}, :as opts} gfn]]}, :source "(defn\n every-impl\n \"Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'\"\n ([form pred opts] (every-impl form pred opts nil))\n ([form\n   pred\n   {gen-into :into,\n    describe-form :clojure.core/describe,\n    :keys\n    [kind\n     :clojure.core/kind-form\n     count\n     max-count\n     min-count\n     distinct\n     gen-max\n     :clojure.core/kfn\n     :clojure.core/cpred\n     conform-keys\n     :clojure.core/conform-all],\n    :or {gen-max 20},\n    :as opts}\n   gfn]\n  (let\n   [conform-into\n    gen-into\n    spec\n    (delay (specize pred))\n    check?\n    (fn* [p1__19510#] (valid? @spec p1__19510#))\n    kfn\n    (c/or kfn (fn [i v] i))\n    addcv\n    (fn [ret i v cv] (conj ret cv))\n    cfns\n    (fn\n     [x]\n     (cond\n      (c/and\n       (vector? x)\n       (c/or (not conform-into) (vector? conform-into)))\n      [identity\n       (fn [ret i v cv] (if (identical? v cv) ret (assoc ret i cv)))\n       identity]\n      (c/and\n       (map? x)\n       (c/or (c/and kind (not conform-into)) (map? conform-into)))\n      [(if conform-keys empty identity)\n       (fn\n        [ret i v cv]\n        (if\n         (c/and (identical? v cv) (not conform-keys))\n         ret\n         (assoc ret (nth (if conform-keys cv v) 0) (nth cv 1))))\n       identity]\n      (c/or\n       (list? conform-into)\n       (seq? conform-into)\n       (c/and (not conform-into) (c/or (list? x) (seq? x))))\n      [empty addcv reverse]\n      :else\n      [(fn* [p1__19511#] (empty (c/or conform-into p1__19511#)))\n       addcv\n       identity]))]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [spec @spec]\n      (cond\n       (not (cpred x))\n       :clojure.core/invalid\n       conform-all\n       (let\n        [[init add complete] (cfns x)]\n        (loop\n         [ret (init x) i 0 [v & vs :as vseq] (seq x)]\n         (if\n          vseq\n          (let\n           [cv (conform* spec v)]\n           (if\n            (invalid? cv)\n            :clojure.core/invalid\n            (recur (add ret i v cv) (inc i) vs)))\n          (complete ret))))\n       :else\n       (if\n        (indexed? x)\n        (let\n         [step (max 1 (long (/ (c/count x) *coll-check-limit*)))]\n         (loop\n          [i 0]\n          (if\n           (>= i (c/count x))\n           x\n           (if\n            (valid? spec (nth x i))\n            (recur (c/+ i step))\n            :clojure.core/invalid))))\n        (let\n         [limit *coll-check-limit*]\n         (loop\n          [i 0 [v & vs :as vseq] (seq x)]\n          (cond\n           (c/or (nil? vseq) (= i limit))\n           x\n           (valid? spec v)\n           (recur (inc i) vs)\n           :else\n           :clojure.core/invalid)))))))\n    (unform*\n     [_ x]\n     (if\n      conform-all\n      (let\n       [spec @spec [init add complete] (cfns x)]\n       (loop\n        [ret (init x) i 0 [v & vs :as vseq] (seq x)]\n        (if\n         (>= i (c/count x))\n         (complete ret)\n         (recur (add ret i v (unform* spec v)) (inc i) vs))))\n      x))\n    (explain*\n     [_ path via in x]\n     (c/or\n      (coll-prob\n       x\n       kind\n       kind-form\n       distinct\n       count\n       min-count\n       max-count\n       path\n       via\n       in)\n      (apply\n       concat\n       ((if conform-all identity (partial take *coll-error-limit*))\n        (keep\n         identity\n         (map\n          (fn\n           [i v]\n           (let\n            [k (kfn i v)]\n            (when-not\n             (check? v)\n             (let\n              [prob (explain-1 form pred path via (conj in k) v)]\n              prob))))\n          (range)\n          x))))))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [pgen (gensub pred overrides path rmap form)]\n       (gen/bind\n        (cond\n         gen-into\n         (gen/return (empty gen-into))\n         kind\n         (gen/fmap\n          (fn*\n           [p1__19512#]\n           (if (empty? p1__19512#) p1__19512# (empty p1__19512#)))\n          (gensub kind overrides path rmap form))\n         :else\n         (gen/return []))\n        (fn\n         [init]\n         (gen/fmap\n          (fn*\n           [p1__19513#]\n           (if (vector? init) p1__19513# (into init p1__19513#)))\n          (cond\n           distinct\n           (if\n            count\n            (gen/vector-distinct\n             pgen\n             {:num-elements count, :max-tries 100})\n            (gen/vector-distinct\n             pgen\n             {:min-elements (c/or min-count 0),\n              :max-elements\n              (c/or\n               max-count\n               (max gen-max (c/* 2 (c/or min-count 0)))),\n              :max-tries 100}))\n           count\n           (gen/vector pgen count)\n           (c/or min-count max-count)\n           (gen/vector\n            pgen\n            (c/or min-count 0)\n            (c/or max-count (max gen-max (c/* 2 (c/or min-count 0)))))\n           :else\n           (gen/vector pgen 0 gen-max))))))))\n    (with-gen* [_ gfn] (every-impl form pred opts gfn))\n    (describe*\n     [_]\n     (c/or\n      describe-form\n      (clojure.core/sequence\n       (clojure.core/seq\n        (clojure.core/concat\n         (clojure.core/list 'clojure.core/every)\n         (clojure.core/list (s/mres form))\n         (mapcat identity opts))))))))))\n"} {:sym spec-impl, :meta {:doc "Do not call this directly, use 'spec'", :arglists [[form pred gfn cpred?] [form pred gfn cpred? unc]]}, :source "(defn\n spec-impl\n \"Do not call this directly, use 'spec'\"\n ([form pred gfn cpred?] (spec-impl form pred gfn cpred? nil))\n ([form pred gfn cpred? unc]\n  (cond\n   (spec? pred)\n   (cond-> pred gfn (with-gen gfn))\n   (regex? pred)\n   (regex-spec-impl pred gfn)\n   (ident? pred)\n   (cond-> (the-spec pred) gfn (with-gen gfn))\n   :else\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [ret (pred x)]\n      (if cpred? ret (if ret x :clojure.core/invalid))))\n    (unform*\n     [_ x]\n     (if\n      cpred?\n      (if unc (unc x) (throw (js/Error. \"no unform fn for conformer\")))\n      x))\n    (explain*\n     [_ path via in x]\n     (when\n      (invalid? (dt pred x form cpred?))\n      [{:path path, :pred form, :val x, :via via, :in in}]))\n    (gen* [_ _ _ _] (if gfn (gfn) (gen/gen-for-pred pred)))\n    (with-gen* [_ gfn] (spec-impl form pred gfn cpred? unc))\n    (describe* [_] form)))))\n"} {:sym invalid?, :meta {:doc "tests the validity of a conform return value", :arglists ([ret])}, :source "(defn\n invalid?\n \"tests the validity of a conform return value\"\n [ret]\n (keyword-identical? :clojure.core/invalid ret))\n"} {:sym amp-impl, :meta {:doc "Do not call this directly, use '&'", :arglists ([re preds pred-forms])}, :source "(defn\n amp-impl\n \"Do not call this directly, use '&'\"\n [re preds pred-forms]\n {:clojure.core/op :clojure.core/amp,\n  :p1 re,\n  :ps preds,\n  :forms pred-forms})\n"} {:sym cat-impl, :meta {:doc "Do not call this directly, use 'cat'", :arglists ([ks ps forms])}, :source "(defn\n cat-impl\n \"Do not call this directly, use 'cat'\"\n [ks ps forms]\n (pcat* {:ks ks, :ps ps, :forms forms, :ret {}}))\n"} {:sym explain-str, :meta {:doc "Given a spec and a value that fails to conform, returns an explanation as a string.", :arglists ([spec x])}, :source "(defn\n explain-str\n \"Given a spec and a value that fails to conform, returns an explanation as a string.\"\n [spec x]\n (with-out-str (explain spec x)))\n"} {:sym *compile-asserts*, :meta {:doc "If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\nInitially set to the negation of the ':elide-asserts' compiler option.\nDefaults to true."}, :source "(defonce *compile-asserts* (s/init-compile-asserts))\n"} {:sym with-gen, :meta {:doc "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator", :arglists ([spec gen-fn])}, :source "(defn\n with-gen\n \"Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator\"\n [spec gen-fn]\n (let\n  [spec (reg-resolve spec)]\n  (if\n   (regex? spec)\n   (assoc spec :clojure.core/gfn gen-fn)\n   (with-gen* (specize spec) gen-fn))))\n"} {:sym conform*, :meta {:doc nil, :arglists ([spec x])}, :protocol Spec} {:sym check-asserts?, :meta {:doc "Returns the value set by check-asserts.", :arglists ([])}, :source "(defn\n check-asserts?\n \"Returns the value set by check-asserts.\"\n []\n *runtime-asserts*)\n"} {:sym rep-impl, :meta {:doc "Do not call this directly, use '*'", :arglists ([form p])}, :source "(defn\n rep-impl\n \"Do not call this directly, use '*'\"\n [form p]\n (rep* p p [] false form))\n"} {:sym describe, :meta {:doc "returns an abbreviated description of the spec as data", :arglists ([spec])}, :source "(defn\n describe\n \"returns an abbreviated description of the spec as data\"\n [spec]\n (abbrev (form spec)))\n"} {:sym explain-out, :meta {:doc "Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n    by default explain-printer.", :arglists ([ed])}, :source "(defn\n explain-out\n \"Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\\n    by default explain-printer.\"\n [ed]\n (*explain-out* ed))\n"} {:sym specize*, :meta {:doc nil, :arglists ([_] [_ form])}, :protocol Specize} {:sym maybe-impl, :meta {:doc "Do not call this directly, use '?'", :arglists ([p form])}, :source "(defn\n maybe-impl\n \"Do not call this directly, use '?'\"\n [p form]\n (assoc\n  (alt* [p (accept :clojure.core/nil)] nil [form :clojure.core/nil])\n  :maybe\n  form))\n"} {:sym explain*, :meta {:doc nil, :arglists ([spec path via in x])}, :protocol Spec}), cljs.spec.gen.alpha ({:sym quick-check, :meta {:doc nil, :arglists ([& args])}, :source "(defn quick-check [& args] (apply @quick-check-ref args))\n"} {:sym for-all*, :meta {:doc "Dynamically loaded clojure.test.check.properties/for-all*.", :arglists ([& args])}, :source "(defn\n for-all*\n \"Dynamically loaded clojure.test.check.properties/for-all*.\"\n [& args]\n (apply @for-all*-ref args))\n"} {:sym delay-impl, :meta {:doc nil, :arglists ([gfnd])}, :source "(defn\n delay-impl\n [gfnd]\n (generator (fn [rnd size] ((:gen @gfnd) rnd size))))\n"} {:sym cat, :meta {:doc "Returns a generator of a sequence catenated from results of\ngens, each of which should generate something sequential.", :arglists ([& gens])}, :source "(defn\n cat\n \"Returns a generator of a sequence catenated from results of\\ngens, each of which should generate something sequential.\"\n [& gens]\n (fmap (fn* [p1__19526#] (apply concat p1__19526#)) (apply tuple gens)))\n"} {:sym gen-for-pred, :meta {:doc "Given a predicate, returns a built-in generator if one exists.", :arglists ([pred])}, :source "(defn\n gen-for-pred\n \"Given a predicate, returns a built-in generator if one exists.\"\n [pred]\n (if (set? pred) (elements pred) (get @gen-builtins pred)))\n"}), clojure.string ({:sym ends-with?, :meta {:doc "True if s ends with substr.", :arglists ([s substr])}, :source "(defn\n ends-with?\n \"True if s ends with substr.\"\n [s substr]\n (gstring/endsWith s substr))\n"} {:sym capitalize, :meta {:doc "Converts first character of the string to upper-case, all other\n  characters to lower-case.", :arglists ([s])}, :source "(defn\n capitalize\n \"Converts first character of the string to upper-case, all other\\n  characters to lower-case.\"\n [s]\n (gstring/capitalize s))\n"} {:sym reverse, :meta {:doc "Returns s with its characters reversed.", :arglists ([s])}, :source "(defn\n reverse\n \"Returns s with its characters reversed.\"\n [s]\n (->\n  (.replace s re-surrogate-pair \"$2$1\")\n  (.. (split \"\") (reverse) (join \"\"))))\n"} {:sym join, :meta {:doc "Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.", :arglists [[coll] [separator coll]]}, :source "(defn\n join\n \"Returns a string of all elements in coll, as returned by (seq coll),\\n  separated by an optional separator.\"\n ([coll]\n  (loop\n   [sb (StringBuffer.) coll (seq coll)]\n   (if-not\n    (nil? coll)\n    (recur (. sb (append (str (first coll)))) (next coll))\n    (.toString sb))))\n ([separator coll]\n  (loop\n   [sb (StringBuffer.) coll (seq coll)]\n   (if-not\n    (nil? coll)\n    (do\n     (. sb (append (str (first coll))))\n     (let\n      [coll (next coll)]\n      (when-not (nil? coll) (. sb (append separator)))\n      (recur sb coll)))\n    (.toString sb)))))\n"} {:sym replace-first, :meta {:doc "Replaces the first instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :arglists ([s match replacement])}, :source "(defn\n replace-first\n \"Replaces the first instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"\n [s match replacement]\n (.replace s match replacement))\n"} {:sym starts-with?, :meta {:doc "True if s starts with substr.", :arglists ([s substr])}, :source "(defn\n starts-with?\n \"True if s starts with substr.\"\n [s substr]\n (gstring/startsWith s substr))\n"} {:sym escape, :meta {:doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", :arglists ([s cmap])}, :source "(defn\n escape\n \"Return a new string, using cmap to escape each character ch\\n   from s as follows:\\n\\n   If (cmap ch) is nil, append ch to the new string.\\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.\"\n [s cmap]\n (let\n  [buffer (StringBuffer.) length (.-length s)]\n  (loop\n   [index 0]\n   (if\n    (== length index)\n    (. buffer (toString))\n    (let\n     [ch (.charAt s index) replacement (get cmap ch)]\n     (if-not\n      (nil? replacement)\n      (.append buffer (str replacement))\n      (.append buffer ch))\n     (recur (inc index)))))))\n"} {:sym last-index-of, :meta {:doc "Return last index of value (string or char) in s, optionally\n  searching backward from from-index or nil if not found.", :arglists [[s value] [s value from-index]]}, :source "(defn\n last-index-of\n \"Return last index of value (string or char) in s, optionally\\n  searching backward from from-index or nil if not found.\"\n ([s value]\n  (let [result (.lastIndexOf s value)] (if (neg? result) nil result)))\n ([s value from-index]\n  (let\n   [result (.lastIndexOf s value from-index)]\n   (if (neg? result) nil result))))\n"} {:sym includes?, :meta {:doc "True if s includes substr.", :arglists ([s substr])}, :source "(defn\n includes?\n \"True if s includes substr.\"\n [s substr]\n (gstring/contains s substr))\n"} {:sym replace, :meta {:doc "Replaces all instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :arglists ([s match replacement])}, :source "(defn\n replace\n \"Replaces all instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"\n [s match replacement]\n (cond\n  (string? match)\n  (.replace\n   s\n   (js/RegExp. (gstring/regExpEscape match) \"g\")\n   replacement)\n  (instance? js/RegExp match)\n  (if\n   (string? replacement)\n   (replace-all s match replacement)\n   (replace-all s match (replace-with replacement)))\n  :else\n  (throw (str \"Invalid match arg: \" match))))\n"} {:sym split-lines, :meta {:doc "Splits s on \n or \r\n.", :arglists ([s])}, :source "(defn split-lines \"Splits s on \\n or \\r\\n.\" [s] (split s #\"\\n|\\r\\n\"))\n"} {:sym lower-case, :meta {:doc "Converts string to all lower-case.", :arglists ([s])}, :source "(defn\n lower-case\n \"Converts string to all lower-case.\"\n [s]\n (.toLowerCase s))\n"} {:sym trim-newline, :meta {:doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", :arglists ([s])}, :source "(defn\n trim-newline\n \"Removes all trailing newline \\\\n or return \\\\r characters from\\n  string.  Similar to Perl's chomp.\"\n [s]\n (loop\n  [index (.-length s)]\n  (if\n   (zero? index)\n   \"\"\n   (let\n    [ch (get s (dec index))]\n    (if\n     (or (identical? \\newline ch) (identical? \\return ch))\n     (recur (dec index))\n     (.substring s 0 index))))))\n"} {:sym upper-case, :meta {:doc "Converts string to all upper-case.", :arglists ([s])}, :source "(defn\n upper-case\n \"Converts string to all upper-case.\"\n [s]\n (.toUpperCase s))\n"} {:sym split, :meta {:doc "Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.", :arglists [[s re] [s re limit]]}, :source "(defn\n split\n \"Splits string on a regular expression. Optional argument limit is\\n  the maximum number of splits. Not lazy. Returns vector of the splits.\"\n ([s re] (split s re 0))\n ([s re limit]\n  (discard-trailing-if-needed\n   limit\n   (if\n    (identical? \"/(?:)/\" (str re))\n    (split-with-empty-regex s limit)\n    (if\n     (< limit 1)\n     (vec (.split (str s) re))\n     (loop\n      [s s limit limit parts []]\n      (if\n       (== 1 limit)\n       (conj parts s)\n       (let\n        [m (re-find re s)]\n        (if-not\n         (nil? m)\n         (let\n          [index (.indexOf s m)]\n          (recur\n           (.substring s (+ index (count m)))\n           (dec limit)\n           (conj parts (.substring s 0 index))))\n         (conj parts s))))))))))\n"} {:sym trimr, :meta {:doc "Removes whitespace from the right side of string.", :arglists ([s])}, :source "(defn\n trimr\n \"Removes whitespace from the right side of string.\"\n [s]\n (gstring/trimRight s))\n"} {:sym index-of, :meta {:doc "Return index of value (string or char) in s, optionally searching\n  forward from from-index or nil if not found.", :arglists [[s value] [s value from-index]]}, :source "(defn\n index-of\n \"Return index of value (string or char) in s, optionally searching\\n  forward from from-index or nil if not found.\"\n ([s value]\n  (let [result (.indexOf s value)] (if (neg? result) nil result)))\n ([s value from-index]\n  (let\n   [result (.indexOf s value from-index)]\n   (if (neg? result) nil result))))\n"} {:sym trim, :meta {:doc "Removes whitespace from both ends of string.", :arglists ([s])}, :source "(defn\n trim\n \"Removes whitespace from both ends of string.\"\n [s]\n (gstring/trim s))\n"} {:sym triml, :meta {:doc "Removes whitespace from the left side of string.", :arglists ([s])}, :source "(defn\n triml\n \"Removes whitespace from the left side of string.\"\n [s]\n (gstring/trimLeft s))\n"} {:sym blank?, :meta {:doc "True is s is nil, empty, or contains only whitespace.", :arglists ([s])}, :source "(defn\n blank?\n \"True is s is nil, empty, or contains only whitespace.\"\n [s]\n (gstring/isEmptySafe s))\n"}), clojure.walk ({:sym walk, :meta {:doc "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :arglists ([inner outer form])}, :source "(defn\n walk\n \"Traverses form, an arbitrary data structure.  inner and outer are\\n  functions.  Applies inner to each element of form, building up a\\n  data structure of the same type, then applies outer to the result.\\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n {:added \"1.1\"}\n [inner outer form]\n (cond\n  (list? form)\n  (outer (apply list (map inner form)))\n  (seq? form)\n  (outer (doall (map inner form)))\n  (record? form)\n  (outer (reduce (fn [r x] (conj r (inner x))) form form))\n  (coll? form)\n  (outer (into (empty form) (map inner form)))\n  :else\n  (outer form)))\n"} {:sym postwalk, :meta {:doc "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :arglists ([f form])}, :source "(defn\n postwalk\n \"Performs a depth-first, post-order traversal of form.  Calls f on\\n  each sub-form, uses f's return value in place of the original.\\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n {:added \"1.1\"}\n [f form]\n (walk (partial postwalk f) f form))\n"} {:sym prewalk, :meta {:doc "Like postwalk, but does pre-order traversal.", :arglists ([f form])}, :source "(defn\n prewalk\n \"Like postwalk, but does pre-order traversal.\"\n {:added \"1.1\"}\n [f form]\n (walk (partial prewalk f) identity (f form)))\n"} {:sym keywordize-keys, :meta {:doc "Recursively transforms all map keys from strings to keywords.", :arglists ([m])}, :source "(defn\n keywordize-keys\n \"Recursively transforms all map keys from strings to keywords.\"\n {:added \"1.1\"}\n [m]\n (let\n  [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n  (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n"} {:sym stringify-keys, :meta {:doc "Recursively transforms all map keys from keywords to strings.", :arglists ([m])}, :source "(defn\n stringify-keys\n \"Recursively transforms all map keys from keywords to strings.\"\n {:added \"1.1\"}\n [m]\n (let\n  [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n  (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n"} {:sym prewalk-replace, :meta {:doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.", :arglists ([smap form])}, :source "(defn\n prewalk-replace\n \"Recursively transforms form by replacing keys in smap with their\\n  values.  Like clojure/replace but works on any data structure.  Does\\n  replacement at the root of the tree first.\"\n {:added \"1.1\"}\n [smap form]\n (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n"} {:sym postwalk-replace, :meta {:doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.", :arglists ([smap form])}, :source "(defn\n postwalk-replace\n \"Recursively transforms form by replacing keys in smap with their\\n  values.  Like clojure/replace but works on any data structure.  Does\\n  replacement at the leaves of the tree first.\"\n {:added \"1.1\"}\n [smap form]\n (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n"})}, :rel-path "../../", :hide-sidebar? true, :static? true, :ns-sym dynadoc.example, :vars [{:sym parse-example, :meta {:arglists ([args])}, :source "(defn parse-example [args]\n  (let [{:keys [meta body]} (s/conform ::args args)\n        _ (when (= meta :clojure.spec/invalid)\n            (throw (Exception. (str \"Invalid args: \" (pr-str args)))))\n        [meta-type meta-val] meta\n        opts (case meta-type\n               :doc {:doc meta-val}\n               :opts meta-val\n               {})\n        body (if (> (count body) 1)\n               (apply list 'do body)\n               (first body))]\n    (assoc opts :body body)))", :spec nil, :examples []}]}</script>
        <script type="text/javascript" src="../../main.js"></script>
    </body>
</html>
